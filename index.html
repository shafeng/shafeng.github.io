<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Shafeng`s blog</title>
  <meta name="author" content="shafeng">
  
  <meta name="description" content="c++">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="Shafeng`s blog"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.ico" rel="icon" type="image/x-ico">
  <link rel="alternate" href="/atom.xml" title="Shafeng`s blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Shafeng`s blog</a></h1>
  <h2><a href="/">road</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">首页</a></li>
    
      <li><a href="/archives">目录</a></li>
    
      <li><a href="/about">关于</a></li>
    
	<li> <a href="/atom.xml">RSS</a> </li>
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-05-08T08:25:34.631Z"><a href="/2016/05/08/hello-world/">2016-05-08</a></time>
      
      
  
    <h1 class="title"><a href="/2016/05/08/hello-world/">Hello World</a></h1>
  

    </header>
    <div class="entry">
      
        <p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick_Start">Quick Start</h2><h3 id="Create_a_new_post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run_server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate_static_files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy_to_remote_sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-11-23T06:10:53.000Z"><a href="/2015/11/23/2015-11-23 english/">2015-11-23</a></time>
      
      
  
    <h1 class="title"><a href="/2015/11/23/2015-11-23 english/">2015-11-23 单词</a></h1>
  

    </header>
    <div class="entry">
      
        <p>optimize </p>
<h2 id="vt-_使最优化，使尽可能有效;">vt.        使最优化，使尽可能有效;</h2><p>inhibit</p>
<h2 id="v-_抑制;_禁止;">v.        抑制; 禁止;</h2><p>rough<br>adj.    粗糙的，崎岖不平的; 粗鲁的; 狂暴的，汹涌的; 未经加工的;<br>vt.        粗暴地对待; 使粗糙; 草拟;<br>n.        粗糙的部分; 艰难，苦难;</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-11-22T07:59:41.706Z"><a href="/2015/11/22/b+tree/">2015-11-22</a></time>
      
      
  
    <h1 class="title"><a href="/2015/11/22/b+tree/">Hello World</a></h1>
  

    </header>
    <div class="entry">
      
        <p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick_Start">Quick Start</h2><h3 id="Create_a_new_post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run_server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate_static_files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy_to_remote_sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-11-12T09:18:53.000Z"><a href="/2015/11/12/explicit&extern/">2015-11-12</a></time>
      
      
  
    <h1 class="title"><a href="/2015/11/12/explicit&extern/">C++中的explicit和extern</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="explicit">explicit</h2><p>C++提供了关键字explicit，可以阻止不应该允许的经过转换构造函数进行的隐式转换的发生。声明为explicit的构造函数不能在隐式转换中使用<br>C++中， 一个参数的构造函数(或者除了第一个参数外其余参数都有默认值的多参构造函数)， 承担了两个角色。 1 是个构造器 ，2 是个默认且隐含的类型转换操作符。<br>explicit构造函数是用来防止隐式转换的。请看下面的代码：<br>    <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Test1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Test1(<span class="keyword">int</span> n)</span><br><span class="line">	&#123;</span><br><span class="line">		num=n;</span><br><span class="line">	&#125;<span class="comment">//普通构造函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> Test2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">Test2</span><span class="params">(<span class="keyword">int</span> n)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		num=n;</span><br><span class="line">	&#125;<span class="comment">//explicit(显式)构造函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	Test1 t1=<span class="number">12</span>;<span class="comment">//隐式调用其构造函数,成功</span></span><br><span class="line">	Test2 t2=<span class="number">12</span>;<span class="comment">//编译错误,不能隐式调用其构造函数</span></span><br><span class="line">	<span class="function">Test2 <span class="title">t2</span><span class="params">(<span class="number">12</span>)</span></span>;<span class="comment">//显式调用成功</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>只要是构造函数中只有一个可变参数的C++类，都要避免隐式调用。</p>
<h2 id="extern">extern</h2><h3 id="extern可置于变量或者函数前，以表示变量或者函数的定义在别的文件中，提示编译器遇到此变量或函数时，在其它模块中寻找其定义。">extern可置于变量或者函数前，以表示变量或者函数的定义在别的文件中，提示编译器遇到此变量或函数时，在其它模块中寻找其定义。</h3><p>下面这段代码没有使用任何 extern 关键字，编译中会报错。<br>    <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//A.cpp</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//B.cpp</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br></pre></td></tr></table></figure></p>
<p>添加extren关键字后可以编译通过，提示编译器i变量定义在其他模块中<br>    <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//A.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	i=<span class="number">100</span>;<span class="comment">//试图使用B中定义的全局变量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//B.cpp</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br></pre></td></tr></table></figure></p>
<h3 id="extern也可用来进行链接指定。">extern也可用来进行链接指定。</h3><p>C++支持函数重载，而过程式语言C则不支持。函数被C++编译后在符号库中的名字与C语言的不同。例如，假设某个函数的原型为：<br>void foo( int x, int y );该函数被C编译器编译后在符号库中的名字为_foo，而C++编译器则会产生像_foo_int_int之类的名字<br>（不同的编译器可能生成的名字不同，但是都采用了相同的机制，生成的新名字称为“mangled name”）。_foo_int_int这样的名字<br>包含了函数名、函数参数数量及类型信息，C++就是靠这种机制来实现函数重载的。例如，在C++中，函数void foo( int x, int y )<br>与void foo( int x, float y )编译生成的符号是不相同的，后者为_foo_int_float。同样地，C++中的变量除支持局部变量外，<br>还支持类成员变量和全局变量。用户所编写程序的类成员变量可能与全局变量同名，我们以”.”来区分。而本质上，编译器在进行编译时，<br>与函数的处理相似，也为类中的变量取了一个独一无二的名字，这个名字与用户程序中同名的全局变量名字不同。<br>在C++中引用C语言中的函数和变量，在包含C语言头文件（假设为cExample.h）时，需进行下列处理：<br>    <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="preprocessor">#<span class="keyword">include</span> <span class="string">"cExample.h"</span>	</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-05-21T09:49:39.000Z"><a href="/2015/05/21/二义性/">2015-05-21</a></time>
      
      
  
    <h1 class="title"><a href="/2015/05/21/二义性/">关于C++继承的二义性</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="关于C++继承的二义性">关于C++继承的二义性</h2><p>天气太热写不下去代码,就翻柜子,找到c++primer翻了一下,好久不看书,记一下翻到的内容,稍微巩固下…<br>给定下面的类层次，从 VMI 类内部可以限定地访问哪些继承成员？哪些继承成员需要限定？解释你的推理。</p>
<pre><code><span class="keyword">class</span> Base {
<span class="keyword">public</span>:
    bar(<span class="keyword">int</span>);
<span class="keyword">protected</span>:
    <span class="keyword">int</span> ival;
};
<span class="keyword">class</span> Derived1 : <span class="keyword">virtual</span> <span class="keyword">public</span> Base {
<span class="keyword">public</span>:
    bar(<span class="keyword">char</span>);
    foo(<span class="keyword">char</span>);
<span class="keyword">protected</span>:
    <span class="keyword">char</span> cval;
};
<span class="keyword">class</span> Derived2 : <span class="keyword">virtual</span> <span class="keyword">public</span> Base {
<span class="keyword">public</span>:
    foo(<span class="keyword">int</span>);
<span class="keyword">protected</span>:
    <span class="keyword">int</span> ival;
    <span class="keyword">char</span> cval;
};
<span class="keyword">class</span> VMI : <span class="keyword">public</span> Derived1, <span class="keyword">public</span> Derived2 { };
</code></pre><p>从这个继承层次看，VMI类内部访问哪些没有二义性，哪些成员有二义性呢？<br>从VMI类内部可以不加限定地访问继承成员bar和ival：bar在共享基类Base和派生类Derived1中都存在，但特定派生类实例的优先级高于共享基类实例，所以在VMI类内部不加限定地访问bar，则访问到的是Derived1中的bar实例。ival在共享基类Base和派生类Derived2中都存在，同理，在VMI类中不加限定地访问ival，访问到的是Derived2中的ival实例。<br>继承成员foo和cval需要限定：二者在Derived1和Derived2中都存在，Derived1和Derived2均为Base的派生类，访问优先级相同，所以，如果在VMI类内不加限定地访问foo和cval，则会出现二义性。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-05-21T09:49:39.000Z"><a href="/2015/05/21/c++11 bind的使用/">2015-05-21</a></time>
      
      
  
    <h1 class="title"><a href="/2015/05/21/c++11 bind的使用/">C++11中bind,function实战记录</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="C++11中bind和function的使用">C++11中bind和function的使用</h3><p>最近在做的项目中有一个需求,我负责向客户端推送一组数据,这些数据需要另一个服务器程序员填充,<br>我需要调用他的一个函数,并把我的填充函数传递给他,然后在他的函数中填充这些数据.</p>
<p>首先我用普通函数试验了一下,因为c++11中的bind和function并没有使用过太多.<br>``` c++</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span>
<span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span>
<span class="keyword">struct</span> Info;
<span class="keyword">typedef</span> <span class="built_in">std</span>::function&lt;Info*()&gt; NewInfo;
<span class="keyword">typedef</span> <span class="built_in">std</span>::function&lt;<span class="keyword">void</span> (<span class="keyword">int</span> key,<span class="keyword">int</span> value)&gt; PropExecute;
<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::placeholders;

<span class="keyword">struct</span> Info
{
    <span class="keyword">int</span> key;
    <span class="keyword">int</span> value;
};

<span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(PropExecute func)</span>
</span>{
    func(<span class="number">1</span>,<span class="number">1</span>);
}
<span class="function"><span class="keyword">void</span> <span class="title">prop</span><span class="params">(<span class="keyword">int</span> key,<span class="keyword">int</span> value,NewInfo f)</span>
</span>{
    Info* info = f();
    info-&gt;key = key;
    info-&gt;value = value;
}
<span class="function">Info* <span class="title">new_info</span><span class="params">()</span>
</span>{
    <span class="keyword">return</span> <span class="keyword">new</span> Info;
}

<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>
</span>{
    test(bind(prop,_1,_2,new_info));
    <span class="keyword">return</span> <span class="number">1</span>;
}
</code></pre><p>这样写就基本实现了该功能,<code>Info</code>和<code>PropExecute</code>函数类型由我公开给服务器同事,<br>同事提供<code>test</code>函数给我调用,并在该函数内使用我传递过去的函数将数据填充(这里我用1,1填充).</p>
<p>好了,现在修改一下,把所有的普通函数都修改为类成员函数,因为项目中这些函数都是类成员函数.</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span>
<span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span>
<span class="keyword">struct</span> Info;
<span class="keyword">typedef</span> <span class="built_in">std</span>::function&lt;Info*()&gt; NewInfo;
<span class="keyword">typedef</span> <span class="built_in">std</span>::function&lt;<span class="keyword">void</span> (<span class="keyword">int</span> key,<span class="keyword">int</span> value)&gt; PropExecute;
<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::placeholders;
<span class="keyword">class</span> Attr
{
<span class="keyword">public</span>:
    Attr():key(<span class="number">1</span>),value(<span class="number">1</span>){}
    ~Attr(){};
    <span class="function"><span class="keyword">void</span> <span class="title">get_attr</span><span class="params">(PropExecute func)</span>
    </span>{
        func(key,value);
    }
    <span class="keyword">int</span> key;
    <span class="keyword">int</span> value;
};
<span class="keyword">class</span> Info
{
<span class="keyword">public</span>:
    Info():key(<span class="number">0</span>),value(<span class="number">0</span>){};
    ~Info(){};
    <span class="function">Info* <span class="title">new_info</span><span class="params">()</span>
    </span>{
        <span class="keyword">return</span> <span class="keyword">new</span> Info;
    }
    <span class="keyword">int</span> key;
    <span class="keyword">int</span> value;
};
<span class="keyword">class</span> MyClass
{
<span class="keyword">public</span>:
    MyClass(){}
    ~MyClass(){}
    <span class="function"><span class="keyword">void</span> <span class="title">set_prop</span><span class="params">(<span class="keyword">int</span> key,<span class="keyword">int</span> value,NewInfo f)</span>
    </span>{
        Info* info = f();
        info-&gt;key = key;
        info-&gt;value = value;
    }
};


<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>
</span>{
    Info info;
    Attr attr;
    MyClass myclass;
    NewInfo newinfo = <span class="built_in">std</span>::bind(&amp;Info::new_info,&amp;info);
    attr.get_attr(bind(&amp;MyClass::set_prop,&amp;myclass,_1,_2,newinfo));
    <span class="keyword">return</span> <span class="number">1</span>;
}
</code></pre><p>修改为类成员函数后就是这样了,这里遇到一个问题,<code>main</code>函数中调用<code>get_attr</code>时分成了两条代码,<br>因为写成这样编译报错<code>attr.get_attr(bind(&amp;MyClass::set_prop,&amp;myclass,_1,_2,std::bind(&amp;Info::new_info,&amp;info)));</code><br>我估计可能是类型不匹配之类的错误.总之分成两条代码就OK了. </p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-04-09T09:15:53.000Z"><a href="/2015/04/09/orm-odb/">2015-04-09</a></time>
      
      
  
    <h1 class="title"><a href="/2015/04/09/orm-odb/">orm-odb(c++)</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="基于ORM机制的C++数据库操作开源库ODB">基于ORM机制的C++数据库操作开源库ODB</h2><p>  最近在项目里遇到一个问题,关于数据库读取大量数据的,这部分代码项目里的思路是,对数据表做索引,然后依据索引排序,取出最上面的max_size(5000)条数据,然后基于后面的数据继续排序,取出最上面max_size(5000)条,依此循环直到取出最后一条数据.  开始我觉得这样可能效率会比较低,因为每次操作都要进行一次排序,我觉得用limit 0,max_size .limit 0+max_size,max_size+max_size这样的方法要快一些,后来想了一下问题的关键应该是在每次取第一条数据的时候,比如先排序再去取的话,因为建立了索引,所以排序是很快的,而且第一条马上就找到了,但是用limit 0,max_size这样的方法的话,每次查找第一条数据都要顺序数到位置,所以先排序再取数据的方法是稍微好一点的. </p>
<hr>
<p>  不过正是因为这个问题,偶然发现了一个c++的数据库操作库,基于ORM机制,google了一下ORM,全称是对象关系映射（Object Relational Mapping),简单来说就是使用这个库可以让程序员避免直接操作sql语句,数据的存储和对象直接相关,多说无益,记下使用方法以便日后用得到.</p>
<hr>
<p> 我是在windows平台上编译和测试的.这里记下windows下的使用方法:<br> 首先从<a href="http://www.codesynthesis.com/products/odb/" target="_blank" rel="external">http://www.codesynthesis.com/products/odb/</a> 下载到源码,主要是the Common Runtime Library和the Database Runtime Library,前者是ODB的基本库,后者是基于不同数据库的扩展库,后者要基于前者.我用的是mysql,所以要下载mysql的扩展库.前者没有任何依赖可以直接编译,后者要基于前者和mysql的库,我编译的时候总是不成功,后来发现我机器上安装的mysql是64位的,编译ODB的时候把win32改成X64后编译通过,以后要注意下这个问题.使用编译好的库启动官方的例子程序”hello”,一切正常.<br> 简单的用法如下:</p>
<p> 这是一个简单的person类.<br> // person.hxx</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span>

<span class="keyword">class</span> person
{
<span class="keyword">public</span>:
  person (<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; first,
          <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; last,
          <span class="keyword">unsigned</span> <span class="keyword">short</span> age);

  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span>&amp; <span class="title">first</span> <span class="params">()</span> <span class="keyword">const</span></span>;
  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span>&amp; <span class="title">last</span> <span class="params">()</span> <span class="keyword">const</span></span>;

  <span class="function"><span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="title">age</span> <span class="params">()</span> <span class="keyword">const</span></span>;
  <span class="function"><span class="keyword">void</span> <span class="title">age</span> <span class="params">(<span class="keyword">unsigned</span> <span class="keyword">short</span>)</span></span>;

<span class="keyword">private</span>:
  <span class="built_in">std</span>::<span class="built_in">string</span> first_;
  <span class="built_in">std</span>::<span class="built_in">string</span> last_;
  <span class="keyword">unsigned</span> <span class="keyword">short</span> age_;
};
</code></pre><p> 使用ODB后修改如下:</p>
<p> // person.hxx</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span>

<span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;odb/core.hxx&gt;</span>     // (1)</span>

<span class="preprocessor">#<span class="keyword">pragma</span> db object           <span class="comment">// (2)</span></span>
<span class="keyword">class</span> person
{
  ...

<span class="keyword">private</span>:
  person () {}              <span class="comment">// (3)</span>

  <span class="keyword">friend</span> <span class="keyword">class</span> odb::access; <span class="comment">// (4)</span>

  <span class="preprocessor">#<span class="keyword">pragma</span> db id auto        <span class="comment">// (5)</span></span>
  <span class="keyword">unsigned</span> <span class="keyword">long</span> id_;        <span class="comment">// (5)</span>

  <span class="built_in">std</span>::<span class="built_in">string</span> first_;
  <span class="built_in">std</span>::<span class="built_in">string</span> last_;
  <span class="keyword">unsigned</span> <span class="keyword">short</span> age_;
};
</code></pre><p> 使用这个sql文件建立数据表<br> //This file was generated by ODB, object-relational mapping (ORM) compiler for C++.</p>
<pre><code><span class="operator"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`person`</span>;</span>

<span class="operator"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`person`</span> (
  <span class="string">`id`</span> <span class="built_in">BIGINT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> PRIMARY <span class="keyword">KEY</span> AUTO_INCREMENT,
  <span class="string">`first`</span> <span class="built_in">TEXT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,
  <span class="string">`last`</span> <span class="built_in">TEXT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,
  <span class="string">`age`</span> <span class="built_in">SMALLINT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>)
 <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span>
</code></pre><p>测试例子如下,执行commit函数后三个person类对象的数据就写入了数据库中,真的非常方便简洁.<br> //driver.cxx</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span>   // std::auto_ptr</span>
<span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span>

<span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;odb/database.hxx&gt;</span></span>
<span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;odb/transaction.hxx&gt;</span></span>

<span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;odb/mysql/database.hxx&gt;</span></span>

<span class="preprocessor">#<span class="keyword">include</span> <span class="string">"person.hxx"</span></span>
<span class="preprocessor">#<span class="keyword">include</span> <span class="string">"person-odb.hxx"</span></span>

using namespace std<span class="comment">;</span>
using namespace odb::core<span class="comment">;</span>

<span class="built_in">int</span>
main (<span class="built_in">int</span> argc, char* argv[])
{
  try
  {
    //auto_ptr&lt;database&gt; db (new odb::mysql::database (argc, argv))<span class="comment">;</span>
    auto_ptr&lt;database&gt; db (new odb::mysql::database(<span class="string">"dll"</span>,<span class="string">"dll"</span>,<span class="string">"odb_test"</span>,<span class="string">"localhost"</span>,<span class="number">3306</span>))<span class="comment">;</span>
    unsigned long john_id, jane_id, joe_id<span class="comment">;</span>

    // Create a few persistent person objects.
    //
    {
      person john (<span class="string">"John"</span>, <span class="string">"Doe"</span>, <span class="number">33</span>)<span class="comment">;</span>
      person jane (<span class="string">"Jane"</span>, <span class="string">"Doe"</span>, <span class="number">32</span>)<span class="comment">;</span>
      person joe (<span class="string">"Joe"</span>, <span class="string">"Dirt"</span>, <span class="number">30</span>)<span class="comment">;</span>

      transaction t (db-&gt;begin ())<span class="comment">;</span>

      // Make objects persistent <span class="literal">and</span> save their ids <span class="keyword">for</span> later use.
      //
      john_id = db-&gt;persist (john)<span class="comment">;</span>
      jane_id = db-&gt;persist (jane)<span class="comment">;</span>
      joe_id = db-&gt;persist (joe)<span class="comment">;</span>

      t.commit ()<span class="comment">;</span>
    }
  }
  catch (<span class="keyword">const</span> odb::exception&amp; e)
  {
    cerr &lt;&lt; e.what () &lt;&lt; endl<span class="comment">;</span>
    <span class="keyword">return</span> <span class="number">1</span><span class="comment">;</span>
  }
}
</code></pre><p>这是ODB官方自带的例子,我们在使用ODB的时候需要自己生成person类的C++文件,使用官方的ODB Compiler,下载后将ODB的bin目录添加到系统的环境变量中,通过person.hxx文件即可得到ODB需要的其他c++文件,类似protobuf的使用.<br>    odb -d mysql –generate-query –generate-schema person.hxx<br>这条命令即可生成person-odb.hxx, person-odb.ixx, person-odb.cxx这三个文件,这样配合编译好的库文件就可以操作数据库了.</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-02-12T07:12:53.000Z"><a href="/2015/02/12/libcurl/">2015-02-12</a></time>
      
      
  
    <h1 class="title"><a href="/2015/02/12/libcurl/">libcurl</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="Windows下libcurl静态库的编译和使用">Windows下libcurl静态库的编译和使用</h2><p>  最近在玩一个游戏,这游戏的服务器是http通信的,就想伪造一些数据看看.想起了curl,于是去下载,结果编译半天总是出错,又浪费了好多时间,现在成功了,记下来.</p>
<hr>
<p> 首先从这里下载最新的源代码<br>  <a href="http://curl.haxx.se/download.html" target="_blank" rel="external">http://curl.haxx.se/download.html</a><br> libcurl是源码,curl是一个http的工具,反正我用libcurl的源码就够了.</p>
<p> 打开找到相应的VC版本工程用VS打开,我用的是VS2012,相应的版本是VC11.</p>
<p> 一开始编译出错,因为这个版本里包含了ssh和ssl的第三方库,我也用不着所以在预编译宏里把关于ssl和ssh的都去掉.</p>
<p> 然后继续编译lib静态库成功了,新建测试工程加入头文件和生成的附加库libcurld.lib,发现有无法识别的外部符号错误,网上找了半天解决方法.</p>
<p> 最后的解决方法是. libcurl的预编译设定为<br><code>WIN32</code><br><code>_DEBUG</code><br><code>BUILDING_LIBCURL</code><br> 测试项目的预编译设置为<br><code>BUILDING_LIBCURL</code><br> 并且在测试项目头文件中添加以下内容<br><code>#define CURL_STATICLIB</code><br><code>#if defined(_DEBUG)</code><br><code>#pragma comment(lib, &quot;libcurld.lib&quot;)</code><br><code>#else</code><br><code>#pragma comment(lib, &quot;libcurl.lib&quot;)</code><br><code>#endif</code><br><code>#pragma comment(lib,&quot;winmm.lib&quot; )</code><br><code>#pragma comment(lib,&quot;ws2_32.lib&quot; )</code><br><code>#pragma comment(lib,&quot;wldap32.lib&quot; )</code></p>
<p>再次编译,搞定.</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-11-19T06:34:39.000Z"><a href="/2014/11/19/protobuf/">2014-11-19</a></time>
      
      
  
    <h1 class="title"><a href="/2014/11/19/protobuf/">protobuf</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="os_x系统下xcode中使用protobuf">os x系统下xcode中使用protobuf</h2><p>最近在用cocos2dx做小游戏,希望用到网络部分,所以希望protobuf能在mac平台上工作,baidu和goole了一下后发现大部分都是重复的一两篇技术文章,转来转去,而且按照这两篇文章搞了一下都没有成功,后来发现了两篇实用的文章后才解决了问题,记录一下:</p>
<p>主要参考两篇在网上流传不广的文章.<br><code>http://blog.csdn.net/deep_coder/article/details/38055275</code><br><code>http://blog.csdn.net/rct1985/article/details/9340641</code></p>
<p>在 <code>https://code.google.com/p/protobuf/downloads/list</code> 这里下载最新的SourceCode工程, 我用的是2.5.0版本，下载完解压下指定目录下。</p>
<p>cd yourDir  </p>
<p>./configure<br>make<br>make check<br>sudo make install  </p>
<p>安装成功后在需要用到protobuf的xcode工程里:<br>a. 把解压完的目录下 protobuf-2.5.0/src/google整个目录拷贝到cocos2d-x工程下的libs目录下。<br>b. 把解压完的目录下 config.h 拷贝到 libs/google 目录下，主要是放到一些宏定义， 没办法，代码被引用了。<br>c. 删除编译多语言相关文件，google/protobuf/compiler 目录是用来编译多语言的，删除<br>d. 删除单元测试文件 所有 <em>*</em>unittest.cc 文件是测试用例（根据文件名猜的），删除, 还有两个tesst打着的文件夹</p>
<p>然后编译,会出现这个错误”#error Host architecture was not detected as supported by protobuf”</p>
<p>解决这个问题的方法是:</p>
<pre><code>In platform_macros<span class="class">.h</span>, Replace

<span class="id">#else</span>
<span class="id">#error</span> Host architecture was not detected as supported by protobuf
<span class="id">#endif</span>


By:
<span class="id">#elif</span> <span class="function"><span class="title">defined</span><span class="params">(__aarch64__)</span></span>
<span class="hexcolor">#def</span>ine GOOGLE_PROTOBUF_ARCH_ARM <span class="number">1</span>
<span class="hexcolor">#def</span>ine GOOGLE_PROTOBUF_ARCH_64_BIT <span class="number">1</span>
<span class="id">#else</span>
<span class="id">#error</span> Host architecture was not detected as supported by protobuf
#endif
</code></pre><p>最后再编译就OK了!</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-03-19T15:19:38.000Z"><a href="/2014/03/19/gameloft-puyo/">2014-03-19</a></time>
      
      
  
    <h1 class="title"><a href="/2014/03/19/gameloft-puyo/">gameloft puyo</a></h1>
  

    </header>
    <div class="entry">
      
        <pre><code>#头文件#
//tetris.h

#ifndef _TETRIS_H_
#define _TETRIS_H_

//#define _TETRIS_DEBUG

#include "include/glut.h"
#include "include/glpng.h"
#include &lt;list&gt;

#pragma comment(lib,"glpng.lib")

#define TETRIS_SCALE 2
#define TETRIS_SCREEN_WIDTH    ((GLint)(96*TETRIS_SCALE))
#define TETRIS_SCREEN_HEIGHT ((GLint)(192*TETRIS_SCALE))

#define TETRIS_INFO_WIDTH 120

#define TETRIS_KEY_ESCAPE 27
#define TETRIS_KEY_UP 72
#define TETRIS_KEY_DOWN 80
#define TETRIS_KEY_LEFT 75
#define TETRIS_KEY_RIGHT 77
#define TETRIS_KEY_SPACE  32
#define TETRIS_KEY_ENTER  13

#define TETRIS_TEXTURE_COUNT 4

#define TETRIS_UNIT_WIDTH 32
#define TETRIS_UNIT_HEIGHT 32

#define TETRIS_COLOR_BLUE 0
#define TETRIS_GREEN_BLUE 1
#define TETRIS_RED_BLUE 2
#define TETRIS_YELLOW_BLUE 3

#define TETRIS_UNITS_NUM (TETRIS_SCREEN_WIDTH/TETRIS_UNIT_WIDTH*TETRIS_SCREEN_HEIGHT/TETRIS_UNIT_HEIGHT)//72

#define TETRIS_COL_NUMS (TETRIS_SCREEN_WIDTH/TETRIS_UNIT_WIDTH)//6
#define TETRIS_ROW_NUMS (TETRIS_SCREEN_HEIGHT/TETRIS_UNIT_HEIGHT)//12

#define TETRIS_FREQUENCY_MAX 32
#define TETRIS_FREQUENCY_MIN 1

#define TETRIS_DELAY_TIME 100


using namespace std<span class="comment">;</span>

struct ImageRec {
    unsigned long sizeX<span class="comment">;</span>
    unsigned long sizeY<span class="comment">;</span>
    char *data<span class="comment">;</span>
}<span class="comment">;</span>

typedef struct _unitData{
    GLubyte angle:2,color:2,fill:2,stat:2<span class="comment">;</span>
}unitData<span class="comment">;</span>

typedef struct{
    GLshort col,row<span class="comment">;</span>
}unitPos<span class="comment">;</span>

typedef struct
{
    GLint mainWindow<span class="comment">; //which windown</span>
    GLint textureCount<span class="comment">; //number of texture the game use</span>
    GLuint theTextures[TETRIS_TEXTURE_COUNT+1]<span class="comment">; //to save information about texture</span>
    unitData units[TETRIS_UNITS_NUM+TETRIS_COL_NUMS*2]<span class="comment">; // 72+12 = 84</span>
    unitData CurUnits[2]<span class="comment">;</span>
    unitPos CurUnitsPos[2]<span class="comment">;</span>
    GLint CurUnitsStat<span class="comment">;</span>
    GLint frequency<span class="comment">; //if frequency be changed,the downing speed of object also be changed.</span>
    GLint frequencymax<span class="comment">; </span>
    GLint score<span class="comment">; //score</span>
    GLint scoreLastLevel<span class="comment">; //score when you pass the last level</span>
    GLint level<span class="comment">; //level</span>
    GLint gamecount<span class="comment">; //counter</span>
    GLboolean gameover<span class="comment">;    // equal to 0: the game is running, equal to 1: game will finish</span>
    GLboolean gamepause<span class="comment">; //tag about pausing the game</span>
    GLboolean updating<span class="comment">;        //</span>
    list&lt;unitData*&gt; pool<span class="comment">;</span>
    list&lt;unitData*&gt; poolex<span class="comment">;</span>
    GLint fontBase<span class="comment">;</span>
    GLboolean levelStart<span class="comment">; </span>
    GLint delay<span class="comment">; // to delay time </span>
    GLint updateLevel<span class="comment">; // </span>
    GLint waitUserTextSy,waitUserTextSydir<span class="comment">;</span>
}tetrisMainData<span class="comment">;</span>


#endif


#源文件#
#include "tetris.h"

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

using namespace std<span class="comment">;</span>
const char *appName="Tetris"<span class="comment">;</span>
const char *texturefiles[]={
"puyo_blue.png",
"puyo_green.png",
"puyo_red.png",
"puyo_yellow.png",
}<span class="comment">;</span>
const GLint TexCoord[4][4][2]={
    <span class="number">0.0,0.0</span>, <span class="number">1.0,0.0</span>, <span class="number">1.0,1.0</span>, <span class="number">0.0,1.0</span>,
        <span class="number">0.0,1.0</span>, <span class="number">0.0,0.0</span>, <span class="number">1.0,0.0</span>, <span class="number">1.0,1.0</span>,
        <span class="number">1.0,1.0</span>, <span class="number">0.0,1.0</span>, <span class="number">0.0,0.0</span>, <span class="number">1.0,0.0</span>,
        <span class="number">1.0,0.0</span>, <span class="number">1.0,1.0</span>, <span class="number">0.0,1.0</span>, <span class="number">0.0,0.0</span>,
}<span class="comment">;</span>

tetrisMainData tetris<span class="comment">;</span>

GLvoid Tetris_InitParam(void)<span class="comment">;</span>


#ifdef _TETRIS_DEBUG

GLvoid tetris_debug(GLint t)
{
    switch(t)
    {
    case 0:
        break<span class="comment">;</span>
    case 1:
        break<span class="comment">;</span>
    case 2:
        break<span class="comment">;</span>
    }
}


#define debugSeg1() \
if(tetris.CurUnitsPos[0].col == tetris.CurUnitsPos[1].col\
   &amp;&amp; tetris.CurUnitsPos[0].row == tetris.CurUnitsPos[1].row)\
   tetris_debug(1)<span class="comment">;</span>

#define debugSeg2()\
if(tetris.CurUnitsPos[0].row &gt; TETRIS_ROW_NUMS+1\
   || tetris.CurUnitsPos[0].row &lt; 0) tetris_debug(2)<span class="comment">;\</span>
if(tetris.CurUnitsPos[0].col &gt; TETRIS_COL_NUMS - 1\
   || tetris.CurUnitsPos[0].col &lt; 0) tetris_debug(2)<span class="comment">;\</span>
if(tetris.CurUnitsPos[1].row &gt; TETRIS_ROW_NUMS+1\
   || tetris.CurUnitsPos[1].row &lt; 0) tetris_debug(2)<span class="comment">;\</span>
if(tetris.CurUnitsPos[1].col &gt; TETRIS_COL_NUMS - 1\
   || tetris.CurUnitsPos[1].col &lt; 0) tetris_debug(2)<span class="comment">;\</span>

#define debugSeg3()\
if(fabs(tetris.CurUnitsPos[0].col - tetris.CurUnitsPos[1].col) &gt; 2 \
|| fabs(tetris.CurUnitsPos[0].row - tetris.CurUnitsPos[1].row) &gt; 2)\
        tetris_debug(3)<span class="comment">;</span>

#endif


//Read bitmap file data.
GLint ReadBMP(const char *filename, ImageRec *image) {

    FILE *file<span class="comment">;</span>
    unsigned long size<span class="comment">;</span>
    unsigned long i<span class="comment">;</span>
    unsigned short int planes<span class="comment">;</span>
    unsigned short int bpp<span class="comment">;</span>
    char temp<span class="comment">;</span>



    if ((file = fopen(filename, "rb"))==NULL) {
        printf("File Not Found : %s\n",filename)<span class="comment">;</span>
        return 0<span class="comment">;</span>
    }

    fseek(file, 18, SEEK_CUR)<span class="comment">;</span>

    if ((i = fread(&amp;image-&gt;sizeX, 4, 1, file)) != 1) {
        printf("Error reading width from %s.\n", filename)<span class="comment">;</span>
        return 0<span class="comment">;</span>
    }

    if ((i = fread(&amp;image-&gt;sizeY, 4, 1, file)) != 1) {
        printf("Error reading height from %s.\n", filename)<span class="comment">;</span>
        return 0<span class="comment">;</span>
    }

    size = image-&gt;sizeX * image-&gt;sizeY * 3<span class="comment">;</span>

    if ((fread(&amp;planes, 2, 1, file)) != 1) {
        printf("Error reading planes from %s.\n", filename)<span class="comment">;</span>
        return 0<span class="comment">;</span>
    }

    if (planes != 1) {
        printf("Planes from %s is not 1: %u\n", filename, planes)<span class="comment">;</span>
        return 0<span class="comment">;</span>
    }

    if ((i = fread(&amp;bpp, 2, 1, file)) != 1) {
        printf("Error reading bpp from %s.\n", filename)<span class="comment">;</span>
        return 0<span class="comment">;</span>
    }

    if (bpp != 24) {
        printf("Bpp from %s is not 24: %u\n", filename, bpp)<span class="comment">;</span>
        return 0<span class="comment">;</span>
    }

    fseek(file, 24, SEEK_CUR)<span class="comment">;</span>

    image-&gt;data = (char *) malloc(size)<span class="comment">;</span>
    if (image-&gt;data == NULL) {
        printf("Error allocating memory for color-corrected image data")<span class="comment">;</span>
        return 0<span class="comment">;</span>
    }

    if ((i = fread(image-&gt;data, size, 1, file)) != 1) {
        printf("Error reading image data from %s.\n", filename)<span class="comment">;</span>
        return 0<span class="comment">;</span>
    }

    for (i=0<span class="comment">;i&lt;size;i+=3) {</span>
        temp = image-&gt;data[i]<span class="comment">;</span>
        image-&gt;data[i] = image-&gt;data[i+2]<span class="comment">;</span>
        image-&gt;data[i+2] = temp<span class="comment">;</span>
    }

    return 1<span class="comment">;</span>
}


//Load texture of font which the game used.
GLboolean LoadBmpTextures(char *file,GLuint *texture)                                  
{
    int Status=0<span class="comment">;                              </span>
    ImageRec *TextureImage=NULL<span class="comment">; </span>

    TextureImage = (ImageRec*)malloc(sizeof(ImageRec))<span class="comment">;</span>
    memset(TextureImage,0,sizeof(ImageRec))<span class="comment">;</span>

    if (ReadBMP(file,TextureImage))
    {
        Status=1<span class="comment">;                           </span>
        glGenTextures(1, texture)<span class="comment">;             </span>
        glBindTexture(GL_TEXTURE_2D, *texture)<span class="comment">;</span>
        glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR)<span class="comment">;</span>
        glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR)<span class="comment">;</span>
        glTexImage2D(GL_TEXTURE_2D, 0, 3, TextureImage-&gt;sizeX, TextureImage-&gt;sizeY, 0, GL_RGB, GL_UNSIGNED_BYTE, TextureImage-&gt;data)<span class="comment">;</span>

    }

    if (TextureImage)                            
    {
        if (TextureImage-&gt;data)            
        {
            free(TextureImage-&gt;data)<span class="comment">;    </span>
        }    
        free(TextureImage)<span class="comment">;</span>
    }

    return Status<span class="comment">;                                 </span>
}


//Create font display list.
GLvoid BuildFont(GLuint *texture)                                
{
    float    cx<span class="comment">;                                    </span>
    float    cy<span class="comment">;        </span>
    tetris.fontBase=glGenLists(256)<span class="comment">;                                </span>
    glBindTexture(GL_TEXTURE_2D, (*texture))<span class="comment">;            </span>
    for (GLint loop=0<span class="comment">; loop&lt;256; loop++)                        </span>
    {
        cx=float(loop%16)/16.0f<span class="comment">;                        </span>
        cy=float(loop/16)/16.0f<span class="comment">;                        </span>

        glNewList(tetris.fontBase+loop,GL_COMPILE)<span class="comment">;            </span>
        glBegin(GL_QUADS)<span class="comment">;                            </span>
        glTexCoord2f(cx,1-cy-0.0625f)<span class="comment">;        </span>
        glVertex2i(0,0)<span class="comment">;                        </span>
        glTexCoord2f(cx+0.0625f,1-cy-0.0625f)<span class="comment">;    </span>
        glVertex2i(32,0)<span class="comment">;                        </span>
        glTexCoord2f(cx+0.0625f,1-cy)<span class="comment">;            </span>
        glVertex2i(32,32)<span class="comment">;                    </span>
        glTexCoord2f(cx,1-cy)<span class="comment">;                    </span>
        glVertex2i(0,32)<span class="comment">;                        </span>
        glEnd()<span class="comment">;                                </span>
        glTranslated(20,0,0)<span class="comment">;                        </span>
        glEndList()<span class="comment">;                                    </span>
    }                                                
}


//Delete the font
GLvoid KillFont(GLvoid)                                    
{
    glDeleteLists(tetris.fontBase,256)<span class="comment">;                            </span>
}


//We can call the function below to display the content you want to...
GLvoid glPrint(GLint x, GLint y, char *string)    
{
    glBindTexture(GL_TEXTURE_2D, tetris.theTextures[TETRIS_TEXTURE_COUNT])<span class="comment">;                                </span>
    glPushMatrix()<span class="comment">;                                        </span>
    glTranslated(x,y,0)<span class="comment">;                                </span>
    glListBase(tetris.fontBase)<span class="comment">;                        </span>
    glCallLists(strlen(string),GL_UNSIGNED_BYTE,string)<span class="comment">;                    </span>
    glPopMatrix()<span class="comment">;                        </span>
}

//
void Texture_Adjust(GLubyte r, GLubyte g, GLubyte b, GLubyte absolute)
{ 
    GLint width, height<span class="comment">; GLubyte* pixels = 0; </span>

    glGetTexLevelParameteriv(GL_TEXTURE_2D, 0, GL_TEXTURE_WIDTH, &amp;width)<span class="comment">;</span>
    glGetTexLevelParameteriv(GL_TEXTURE_2D, 0, GL_TEXTURE_HEIGHT, &amp;height)<span class="comment">; </span>

    pixels = (GLubyte*)malloc(width*height*4)<span class="comment">; </span>

    if( pixels == 0 ) return<span class="comment">; </span>

    glGetTexImage(GL_TEXTURE_2D, 0, GL_BGRA_EXT, GL_UNSIGNED_BYTE, pixels)<span class="comment">;     </span>
    { 
        GLint i<span class="comment">;</span>
        GLint count = width * height<span class="comment">; </span>
        for(i=0<span class="comment">; i&lt;count; ++i) </span>
        { 
            if( abs(pixels[i*4] - b) &lt;= absolute
                &amp;&amp; abs(pixels[i*4+1] - g) &lt;= absolute 
                &amp;&amp; abs(pixels[i*4+2] - r) &lt;= absolute ) 
                pixels[i*4+3] = 0<span class="comment">;</span>
            else 
                pixels[i*4+3] = 255<span class="comment">; </span>
        } 
    } 

    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_BGRA_EXT, GL_UNSIGNED_BYTE, pixels)<span class="comment">; </span>
    free(pixels)<span class="comment">;</span>
}

//
void Texture_SetAlpha(GLubyte r, GLubyte g, GLubyte b,GLubyte absolute,GLubyte alpha)
{ 
    GLint width, height<span class="comment">; GLubyte* pixels = 0; </span>

    glGetTexLevelParameteriv(GL_TEXTURE_2D, 0, GL_TEXTURE_WIDTH, &amp;width)<span class="comment">;</span>
    glGetTexLevelParameteriv(GL_TEXTURE_2D, 0, GL_TEXTURE_HEIGHT, &amp;height)<span class="comment">; </span>

    pixels = (GLubyte*)malloc(width*height*4)<span class="comment">; </span>

    if( pixels == 0 ) return<span class="comment">; </span>

    glGetTexImage(GL_TEXTURE_2D, 0, GL_BGRA_EXT, GL_UNSIGNED_BYTE, pixels)<span class="comment">;     </span>
    { 
        GLint i<span class="comment">;</span>
        GLint count = width * height<span class="comment">; </span>
        for(i=0<span class="comment">; i&lt;count; ++i){</span>

            if( abs(pixels[i*4] - b) &lt;= absolute
                &amp;&amp; abs(pixels[i*4+1] - g) &lt;= absolute 
                &amp;&amp; abs(pixels[i*4+2] - r) &lt;= absolute ) 
                pixels[i*4+3] = alpha<span class="comment">;        </span>
        }        
    } 

    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_BGRA_EXT, GL_UNSIGNED_BYTE, pixels)<span class="comment">; </span>
    free(pixels)<span class="comment">;</span>
}


//If the size of screen is changed,the function will be called.
//to readjust the screen param.
GLvoid changeWindow(GLsizei w, GLsizei h)
{
    if (h == 0) h = 1<span class="comment">;</span>
    glViewport(0, 0, w, h)<span class="comment">;</span>
    glMatrixMode(GL_PROJECTION)<span class="comment">;</span>
    glLoadIdentity()<span class="comment">;</span>
    if (w &lt;= h){
        gluOrtho2D(0.0, TETRIS_SCREEN_WIDTH, 0.0, TETRIS_SCREEN_WIDTH * (GLfloat) h/(GLfloat) w)<span class="comment">;</span>
        glScalef(1.0,((float)h/TETRIS_SCREEN_HEIGHT)/((float)w/TETRIS_SCREEN_WIDTH),1.0)<span class="comment">;</span>

    }
    else{
        gluOrtho2D(0.0, TETRIS_SCREEN_HEIGHT * (GLfloat) w/(GLfloat) h, 0.0, TETRIS_SCREEN_HEIGHT)<span class="comment">;</span>

        glScalef(((float)w/TETRIS_SCREEN_WIDTH)/((float)h/TETRIS_SCREEN_HEIGHT),<span class="number">1.0,1.0</span>)<span class="comment">;</span>
    }    
    glMatrixMode(GL_MODELVIEW)<span class="comment">;</span>
    glLoadIdentity()<span class="comment">;    </span>
}

//load all resource will be used.
GLvoid LoadGLTextures()
{
    glPixelStorei(GL_UNPACK_ALIGNMENT, 1)<span class="comment">;    </span>
    pngInfo info[4]<span class="comment">;</span>
    for (int k=0<span class="comment">; k &lt; TETRIS_TEXTURE_COUNT; k++){</span>
        glGenTextures(1,&amp;tetris.theTextures[k])<span class="comment">;</span>
        tetris.theTextures[k] = pngBind(texturefiles[k], PNG_NOMIPMAP, PNG_ALPHA, &amp;info[k], GL_CLAMP, GL_NEAREST, GL_NEAREST)<span class="comment">;</span>
        Texture_Adjust(<span class="number">255,255,255,10</span>)<span class="comment">;</span>
    }
    LoadBmpTextures("buchstabenalpha.bmp",&amp;tetris.theTextures[TETRIS_TEXTURE_COUNT])<span class="comment">;</span>
    Texture_Adjust(<span class="number">0,0,0,11</span>)<span class="comment">;</span>
    Texture_SetAlpha(<span class="number">133,133,133,122</span>,128)<span class="comment">;    </span>
    BuildFont(&amp;tetris.theTextures[TETRIS_TEXTURE_COUNT])<span class="comment">;        </span>
}


//Draw a sprites
GLvoid render2Dsprite(GLint x,GLint y,GLint w,GLint h,GLint textureId,GLint angle=0)
{        
    const GLint (*p)[2]=TexCoord[angle]<span class="comment">;</span>
    glBindTexture(GL_TEXTURE_2D,textureId)<span class="comment">;</span>
    glBegin (GL_POLYGON)<span class="comment">;</span>
    glTexCoord2f(p[0][0], p[0][1])<span class="comment">;    </span>
    glVertex2f (x, y)<span class="comment">;</span>
    glTexCoord2f(p[1][0], p[1][1])<span class="comment">;</span>
    glVertex2f (x+w, y)<span class="comment">;</span>
    glTexCoord2f(p[2][0], p[2][1])<span class="comment">;</span>
    glVertex2f (x+w, y+h)<span class="comment">;</span>
    glTexCoord2f(p[3][0], p[3][1])<span class="comment">;</span>
    glVertex2f (x, y+h)<span class="comment">;</span>
    glEnd ()<span class="comment">;    </span>
}


//Draw the scene of the game.
GLvoid render()
{
    glutSetWindow(tetris.mainWindow)<span class="comment">;</span>
    glClearColor(0.0, 0.0, 0.0, 1.0)<span class="comment">;</span>
    glClear (GL_COLOR_BUFFER_BIT)<span class="comment">;</span>
    glLoadIdentity()<span class="comment">;</span>
    glPushMatrix()<span class="comment">;</span>

    char str[32]<span class="comment">;</span>

    glPushMatrix()<span class="comment">;</span>
    glEnable (GL_BLEND)<span class="comment">;</span>

        glLoadIdentity()<span class="comment">;</span>
        str[0] = '\0'<span class="comment">;</span>
        strcpy(str,"Tetris")<span class="comment">;</span>
        glTranslatef(0.0,TETRIS_SCREEN_HEIGHT/2,0.0)<span class="comment">;</span>
        glScalef(<span class="number">3.2,3.2</span>,1.0)<span class="comment">;        </span>
        glPrint(<span class="number">0.0,0.0</span>,str)<span class="comment">;</span>
        glDisable(GL_BLEND)<span class="comment">;        </span>
    glPopMatrix()<span class="comment">;    </span>
    glPushMatrix()<span class="comment">;    </span>

        if(tetris.gameover){
            if(tetris.gamecount&gt;&gt;4&amp;1){
            glTranslatef(30,TETRIS_SCREEN_HEIGHT/<span class="number">2.0,0.0</span>)<span class="comment">;            </span>
            glScalef(<span class="number">1.5,1.5</span>,1.0)<span class="comment">;        </span>
            glPrint(<span class="number">0.0,0.0</span>,"Game Over!")<span class="comment">;    </span>
            }
        }

        if(tetris.levelStart==1){
            if(tetris.gamecount&gt;&gt;4&amp;1){
                glTranslatef(50,TETRIS_SCREEN_HEIGHT/<span class="number">2.0,0.0</span>)<span class="comment">;</span>
                str[0] = '\0'<span class="comment">;</span>
                sprintf(str,"Level %d",tetris.level)<span class="comment">;</span>
                glScalef(<span class="number">2.0,2.0</span>,1.0)<span class="comment">;        </span>
                glPrint(<span class="number">0.0,0.0</span>,str)<span class="comment">;</span>
            }
        }

        if(tetris.levelStart == 2)
        {

            if(tetris.gamecount&gt;&gt;4&amp;1){
                glTranslatef(20.0,TETRIS_SCREEN_HEIGHT/2.0+tetris.waitUserTextSy,0.0)<span class="comment">;    </span>
                glScalef(<span class="number">0.8,0.8</span>,1.0)<span class="comment">;</span>
                glPrint(<span class="number">0.0,0.0</span>,"Press Enter to replay.")<span class="comment">;</span>
            }

            if(tetris.waitUserTextSydir){
                tetris.waitUserTextSy += 2<span class="comment">;</span>
                if(tetris.waitUserTextSy &gt; TETRIS_SCREEN_HEIGHT/2 - 32)
                    tetris.waitUserTextSydir = 0<span class="comment">;</span>
            }else{
                tetris.waitUserTextSy -= 2<span class="comment">;</span>
                if(tetris.waitUserTextSy &lt; -(TETRIS_SCREEN_HEIGHT/2 - 32))
                    tetris.waitUserTextSydir = 1<span class="comment">;</span>
            }            
        }

        if(tetris.updateLevel)
        {
            tetris.updateLevel--<span class="comment">;</span>
            if(tetris.updateLevel&gt;TETRIS_DELAY_TIME){
                if(tetris.gamecount&gt;&gt;4&amp;1){
                    glTranslatef(35.0,TETRIS_SCREEN_HEIGHT/<span class="number">2.0,0.0</span>)<span class="comment">;    </span>
                    glScalef(<span class="number">0.8,0.8</span>,1.0)<span class="comment">;</span>
                    glPrint(<span class="number">0.0,0.0</span>,"Congratulation!")<span class="comment">;</span>
                    glTranslatef(-15.0,-<span class="number">20.0,0.0</span>)<span class="comment">;</span>
                    glPrint(<span class="number">0.0,0.0</span>,"Level updating!")<span class="comment">;</span>
                }
            }else{
                if(tetris.gamecount&gt;&gt;4&amp;1){
                    glTranslatef(50,TETRIS_SCREEN_HEIGHT/<span class="number">2.0,0.0</span>)<span class="comment">;</span>
                    str[0] = '\0'<span class="comment">;</span>
                    sprintf(str,"Level %d",tetris.level)<span class="comment">;</span>
                    glScalef(<span class="number">2.0,2.0</span>,1.0)<span class="comment">;        </span>
                    glPrint(<span class="number">0.0,0.0</span>,str)<span class="comment">;</span>
                }
            }
        }
        glPopMatrix()<span class="comment">;</span>

    unitData *p=tetris.units,*pTemp<span class="comment">;</span>
    for(int j=0<span class="comment">;j&lt;TETRIS_ROW_NUMS;j++){    </span>
        for(int i=0<span class="comment">;i&lt;TETRIS_COL_NUMS;i++){</span>
            pTemp = &amp;p[j*TETRIS_COL_NUMS+i]<span class="comment">;</span>
            if(pTemp-&gt;fill){                
                glPushMatrix()<span class="comment">;                </span>
                render2Dsprite(i*TETRIS_UNIT_WIDTH,j*TETRIS_UNIT_HEIGHT,TETRIS_UNIT_WIDTH,TETRIS_UNIT_HEIGHT,tetris.theTextures[pTemp-&gt;color],pTemp-&gt;angle)<span class="comment">; </span>
                glPopMatrix()<span class="comment">;            </span>
            }
        }    
    }

    glPushMatrix()<span class="comment">;    </span>
        glEnable (GL_BLEND)<span class="comment">;</span>
        glDisable(GL_ALPHA_TEST)<span class="comment">; </span>
        glLoadIdentity()<span class="comment">;</span>
        glTranslatef(0.0,TETRIS_SCREEN_HEIGHT-32,0.0)<span class="comment">;                    </span>
        glPushMatrix()<span class="comment">;</span>
            str[0] = '\0'<span class="comment">;</span>
            glScalef(<span class="number">0.8,0.8</span>,1.0)<span class="comment">;</span>
            sprintf(str,"Score:%d",tetris.score)<span class="comment">;</span>
            glPrint(<span class="number">0.0,0.0</span>,str)<span class="comment">;</span>
        glPopMatrix()<span class="comment">;    </span>
        glTranslatef(TETRIS_SCREEN_WIDTH*<span class="number">2/3,0.0</span>,0.0)<span class="comment">;</span>
        glPushMatrix()<span class="comment">;</span>
            str[0] = '\0'<span class="comment">;</span>
            glScalef(<span class="number">0.8,0.8</span>,1.0)<span class="comment">;</span>
            sprintf(str,"Level:%d",tetris.level)<span class="comment">;</span>
            glPrint(<span class="number">0.0,0.0</span>,str)<span class="comment">;</span>
        glPopMatrix()<span class="comment">;</span>

        glTranslatef(-TETRIS_SCREEN_WIDTH*2/3,-<span class="number">20.0,0.0</span>)<span class="comment">;</span>
        glPushMatrix()<span class="comment">;            </span>
        glScalef(<span class="number">0.7,0.7</span>,1.0)<span class="comment">;        </span>
        glPrint(<span class="number">0.0,0.0</span>,"Press Space to pause.")<span class="comment">;</span>
        glTranslatef(0.0,-<span class="number">20.0,0.0</span>)<span class="comment">;</span>
        glPrint(<span class="number">0.0,0.0</span>,"Press Esc to exit.")<span class="comment">;</span>
        glPopMatrix()<span class="comment">;</span>

        glDisable(GL_BLEND)<span class="comment">;</span>
        glEnable (GL_ALPHA_TEST)<span class="comment">;</span>
    glPopMatrix()<span class="comment">;    </span>

    glEnd ()<span class="comment">;</span>
    glPopMatrix()<span class="comment">;    </span>
    glutSwapBuffers()<span class="comment">;    </span>
}

GLvoid Tetris_SetSingleUnit(unitData *p,GLint color,GLint angle)
{
    p-&gt;fill = 1<span class="comment">; p-&gt;color = color; p-&gt;angle = angle;</span>
}


//Rotate the object.
GLvoid Tetris_TwoUnitRotate()
{
    if(tetris.CurUnitsStat != 1) return<span class="comment">;</span>

    unitData *pDest=NULL,*pMid=NULL,*pTemp<span class="comment">;</span>
    unitData (*pa)[TETRIS_COL_NUMS]=(unitData (*)[TETRIS_COL_NUMS])tetris.units<span class="comment">;</span>

    pTemp = &amp;pa[tetris.CurUnitsPos[0].row][tetris.CurUnitsPos[0].col]<span class="comment">;</span>

    if(tetris.CurUnitsPos[1].col == tetris.CurUnitsPos[0].col){        
        if(tetris.CurUnitsPos[1].row &lt; tetris.CurUnitsPos[0].row){
            if(tetris.CurUnitsPos[1].col == TETRIS_COL_NUMS - 1) return<span class="comment">;</span>
            pMid = pTemp - TETRIS_COL_NUMS + 1<span class="comment">;</span>
            pDest = pTemp + 1<span class="comment">;</span>
        }else if(tetris.CurUnitsPos[1].row &gt; tetris.CurUnitsPos[0].row){
            if(tetris.CurUnitsPos[1].col == 0) return<span class="comment">;</span>
            pMid = pTemp + TETRIS_COL_NUMS - 1<span class="comment">;</span>
            pDest = pTemp - 1<span class="comment">;</span>
        }else{
#ifdef _TETRIS_DEBUG
            tetris_debug(0)<span class="comment">;</span>
#endif
        }
    }else if(tetris.CurUnitsPos[1].row == tetris.CurUnitsPos[0].row){
        if(tetris.CurUnitsPos[1].col &lt; tetris.CurUnitsPos[0].col){
            if(tetris.CurUnitsPos[1].row == 0) return<span class="comment">;</span>
            pMid = pTemp - TETRIS_COL_NUMS - 1<span class="comment">;</span>
            pDest = pTemp - TETRIS_COL_NUMS<span class="comment">;</span>
        }else if(tetris.CurUnitsPos[1].col &gt; tetris.CurUnitsPos[0].col){
            pMid = pTemp + TETRIS_COL_NUMS + 1<span class="comment">;</span>
            pDest = pTemp + TETRIS_COL_NUMS<span class="comment">;</span>
        }else{
#ifdef _TETRIS_DEBUG
            tetris_debug(0)<span class="comment">;</span>
#endif
        }        
    }else {
#ifdef _TETRIS_DEBUG
        tetris_debug(0)<span class="comment">;</span>
#endif
    }

    if(NULL == pDest || NULL == pMid) return<span class="comment">;</span>

    if(pDest-&gt;fill || pMid-&gt;fill) return<span class="comment">;</span>

    pa[tetris.CurUnitsPos[1].row][tetris.CurUnitsPos[1].col].fill = 0<span class="comment">;    </span>

    tetris.CurUnitsPos[1].col = (pDest - tetris.units) % TETRIS_COL_NUMS<span class="comment">;</span>
    tetris.CurUnitsPos[1].row = (pDest - tetris.units) / TETRIS_COL_NUMS<span class="comment">;</span>

    tetris.CurUnits[1].angle = (tetris.CurUnits[1].angle+1)%4<span class="comment">;</span>
    tetris.CurUnits[0].angle = (tetris.CurUnits[0].angle+1)%4<span class="comment">;</span>

    pa[tetris.CurUnitsPos[0].row][tetris.CurUnitsPos[0].col].angle = tetris.CurUnits[0].angle<span class="comment">;</span>

    Tetris_SetSingleUnit(pDest,tetris.CurUnits[1].color,tetris.CurUnits[1].angle)<span class="comment">;</span>

}


//Call back function about keyboard.
GLvoid keys(unsigned char key, GLint x, GLint y)
{
    if(key == TETRIS_KEY_ESCAPE) exit(0)<span class="comment">;</span>

    if(key == TETRIS_KEY_SPACE) { tetris.gamepause = (++tetris.gamepause)%2<span class="comment">;}</span>

    if(key == TETRIS_KEY_ENTER) {
        tetris.levelStart = 0<span class="comment">;</span>
        tetris.delay = TETRIS_DELAY_TIME<span class="comment">;</span>
        Tetris_InitParam()<span class="comment">;</span>

    }

    if(tetris.CurUnitsStat != 1) return<span class="comment">;</span>
    if(tetris.gamepause) return<span class="comment">;</span>
    if(tetris.levelStart) return<span class="comment">;</span>
    if(tetris.gameover) return<span class="comment">;</span>

    unitData (*pa)[TETRIS_COL_NUMS]=(unitData (*)[TETRIS_COL_NUMS])tetris.units<span class="comment">;</span>
    unitData *pUnitTemp[2]<span class="comment">;</span>

    GLint i,j,k<span class="comment">;</span>

    for(i=0<span class="comment">;i&lt;2;i++)</span>
        pUnitTemp[i] = &amp;pa[tetris.CurUnitsPos[i].row][tetris.CurUnitsPos[i].col]<span class="comment">;</span>

    switch(key)
    {
    case TETRIS_KEY_SPACE:        
        break<span class="comment">;</span>
    case TETRIS_KEY_UP:
        Tetris_TwoUnitRotate()<span class="comment">;</span>
        break<span class="comment">;</span>
    case TETRIS_KEY_DOWN:        
        tetris.frequency = TETRIS_FREQUENCY_MIN<span class="comment">;</span>
        break<span class="comment">;</span>
    case TETRIS_KEY_LEFT:
        j = tetris.CurUnitsPos[0].col &lt;= tetris.CurUnitsPos[1].col<span class="comment">;</span>
        for(k=0<span class="comment">;k&lt;2;k++){</span>
            if(j == 0) i = (k+1)%2<span class="comment">;</span>
            else i = k<span class="comment">;        </span>
            if(tetris.CurUnits[i].stat) continue<span class="comment">;</span>
            if(tetris.CurUnitsPos[i].col &gt; 0
                &amp;&amp; !(pUnitTemp[i]-1)-&gt;fill){
                tetris.CurUnitsPos[i].col--<span class="comment">;</span>
                pUnitTemp[i]-&gt;fill = 0<span class="comment">;                 </span>
                Tetris_SetSingleUnit(pUnitTemp[i]-1,tetris.CurUnits[i].color,tetris.CurUnits[i].angle)<span class="comment">;    </span>
            }
        }
        break<span class="comment">;</span>
    case TETRIS_KEY_RIGHT:
        j = tetris.CurUnitsPos[0].col &gt;= tetris.CurUnitsPos[1].col<span class="comment">;</span>
        for(k=0<span class="comment">;k&lt;2;k++){            </span>
            if(j == 0) i = (k+1)%2<span class="comment">;</span>
            else i = k<span class="comment">;</span>
            if(tetris.CurUnits[i].stat) continue<span class="comment">;</span>
            if(tetris.CurUnitsPos[i].col &lt; TETRIS_COL_NUMS - 1
                &amp;&amp; !(pUnitTemp[i]+1)-&gt;fill){    
                tetris.CurUnitsPos[i].col++<span class="comment">;</span>
                pUnitTemp[i]-&gt;fill = 0<span class="comment">;</span>
                Tetris_SetSingleUnit(pUnitTemp[i]+1,tetris.CurUnits[i].color,tetris.CurUnits[i].angle)<span class="comment">;</span>
            }
        }
        break<span class="comment">;</span>
    }
    glutPostRedisplay()<span class="comment">;</span>
}



GLvoid specialKeysPressed(GLint key, GLint x, GLint y)
{
    switch(key)
    {
    case GLUT_KEY_UP:
        keys(TETRIS_KEY_UP,0,0)<span class="comment">;</span>
        break<span class="comment">;</span>
    case GLUT_KEY_DOWN:
        keys(TETRIS_KEY_DOWN,0,0)<span class="comment">;        </span>
        break<span class="comment">;</span>
    case GLUT_KEY_LEFT:
        keys(TETRIS_KEY_LEFT,0,0)<span class="comment">;</span>
        break<span class="comment">;</span>
    case GLUT_KEY_RIGHT:
        keys(TETRIS_KEY_RIGHT,0,0)<span class="comment">;         </span>
        break<span class="comment">;</span>
    }    
}

GLvoid Tetris_InitMem(void*start,GLint size)
{
    GLbyte *p=(GLbyte*)start<span class="comment">;</span>
    while(size--) (*p) = 0<span class="comment">;</span>
}

GLvoid Tetris_InitTwoUnits(unitData*p)
{
    GLint tmp=rand()%3<span class="comment">;</span>

    switch(tmp)
    {
    case 0:
        tmp = TETRIS_COL_NUMS / 2 - 1<span class="comment">;</span>
        tetris.CurUnitsPos[0].col = tmp<span class="comment">;</span>
        tetris.CurUnitsPos[1].col = tmp+1<span class="comment">;</span>
        tetris.CurUnitsPos[0].row = TETRIS_ROW_NUMS<span class="comment">;</span>
        tetris.CurUnitsPos[1].row = TETRIS_ROW_NUMS<span class="comment">;        </span>
        break<span class="comment">;</span>
    case 1:
        tmp = TETRIS_COL_NUMS / 2 - 1<span class="comment">;</span>
        tetris.CurUnitsPos[0].col = tmp<span class="comment">;</span>
        tetris.CurUnitsPos[1].col = tmp<span class="comment">;</span>
        tetris.CurUnitsPos[0].row = TETRIS_ROW_NUMS<span class="comment">;</span>
        tetris.CurUnitsPos[1].row = TETRIS_ROW_NUMS+1<span class="comment">;</span>
        break<span class="comment">;</span>
    case 2:
        tmp = TETRIS_COL_NUMS / 2<span class="comment">;</span>
        tetris.CurUnitsPos[0].col = tmp<span class="comment">;</span>
        tetris.CurUnitsPos[1].col = tmp<span class="comment">;</span>
        tetris.CurUnitsPos[0].row = TETRIS_ROW_NUMS<span class="comment">;</span>
        tetris.CurUnitsPos[1].row = TETRIS_ROW_NUMS+1<span class="comment">;</span>
        break<span class="comment">;</span>
    }

    Tetris_InitMem(&amp;p[0],sizeof(unitData))<span class="comment">;</span>
    p[0].color = rand()%4<span class="comment">;</span>
    Tetris_InitMem(&amp;p[1],sizeof(unitData))<span class="comment">;</span>
    p[1].color = rand()%4<span class="comment">;</span>
    tetris.CurUnitsStat = 1<span class="comment">;</span>
}

GLvoid Tetris_GameOver()
{
    memset(tetris.units,0,sizeof(tetris.units))<span class="comment">;</span>
    tetris.pool.clear()<span class="comment">;</span>
    tetris.poolex.clear()<span class="comment">;</span>
}


//
GLboolean Tetris_TwoUnitsFunc(unitData *p)
{
    unitData (*pa)[TETRIS_COL_NUMS]=(unitData (*)[TETRIS_COL_NUMS])tetris.units<span class="comment">;</span>
    unitData *pUnitTemp[2],*ps<span class="comment">;</span>

    GLint i,j,k,cnt<span class="comment">;</span>

    for(i=0<span class="comment">;i&lt;2;i++)</span>
        pUnitTemp[i] = &amp;pa[tetris.CurUnitsPos[i].row][tetris.CurUnitsPos[i].col]<span class="comment">;    </span>

    if(tetris.gamecount % tetris.frequency){ return 0<span class="comment">;}</span>
    else{    
        j = (tetris.CurUnitsPos[0].row &lt;= tetris.CurUnitsPos[1].row)<span class="comment">;</span>
        cnt = 0<span class="comment">;</span>
        for(k=0<span class="comment">;k&lt;2;k++){</span>
            if(j == 0) i = (k+1)%2<span class="comment">;</span>
            else i = k<span class="comment">;</span>
            if(0 != p[i].stat) 
                continue<span class="comment">;</span>
            cnt++<span class="comment">;</span>
            ps = pUnitTemp[i] - TETRIS_COL_NUMS<span class="comment">;</span>
            if(ps &gt;= tetris.units){    
                if(ps-&gt;fill &lt; 2){
                    if(--tetris.CurUnitsPos[i].row &lt; 0) 
                        tetris.CurUnitsPos[i].row = 0<span class="comment">;                        </span>
                    Tetris_SetSingleUnit(ps,p[i].color,p[i].angle)<span class="comment">;                    </span>
                    pUnitTemp[i]-&gt;fill = 0<span class="comment">;                        </span>
                }else {
                    if(ps &lt; &amp;tetris.units[TETRIS_UNITS_NUM])
                    {
                        pUnitTemp[i]-&gt;fill = 2<span class="comment">;</span>
                        if(pUnitTemp[i] &gt; &amp;tetris.units[TETRIS_UNITS_NUM] - TETRIS_COL_NUMS )
                        {
                            tetris.gameover = 1<span class="comment">;</span>
                            tetris.delay = TETRIS_DELAY_TIME*2<span class="comment">;</span>
                            Tetris_GameOver()<span class="comment">;</span>
                            return 1<span class="comment">;</span>
                        }
                    }
                    p[i].stat = 1<span class="comment">;                </span>
                }
            }else{
                p[i].stat = 1<span class="comment">;                </span>
                pUnitTemp[i]-&gt;fill = 2<span class="comment">;                        </span>
            }
        }
        if(0 == cnt) tetris.CurUnitsStat = 2<span class="comment">;</span>

        tetris.updating = 1<span class="comment">;</span>
        tetris.pool.clear()<span class="comment">;</span>
        tetris.pool.push_back(&amp;pa[tetris.CurUnitsPos[0].row][tetris.CurUnitsPos[0].col])<span class="comment">;</span>
        tetris.pool.push_back(&amp;pa[tetris.CurUnitsPos[1].row][tetris.CurUnitsPos[1].col])<span class="comment">;</span>
    }
    return 1<span class="comment">;</span>
}



GLvoid Tetris_Update()
{
    GLint i,j,cnt=0<span class="comment">;</span>

    unitData (*pa)[TETRIS_COL_NUMS]=(unitData (*)[TETRIS_COL_NUMS])tetris.units<span class="comment">;</span>

    list&lt;unitData*&gt; *pool<span class="comment">;</span>
    list&lt;unitData*&gt;<span class="number">::</span>iterator iter<span class="comment">;    </span>

    GLint col,row<span class="comment">;</span>

    pool = &amp;tetris.poolex<span class="comment">;</span>

    for(cnt=0,iter=pool-&gt;begin()<span class="comment">;iter != pool-&gt;end(); iter++)</span>
    {
        unitData *p,*q<span class="comment">;</span>

        p = q = (*iter)<span class="comment">;</span>

        i = 0<span class="comment">;</span>
        p += TETRIS_COL_NUMS<span class="comment">;</span>
        while(p &lt; &amp;tetris.units[TETRIS_UNITS_NUM] &amp;&amp; p-&gt;fill) { i++<span class="comment">; p += TETRIS_COL_NUMS; }</span>

        if(i &gt; 0)
        {            
            p = (*iter)<span class="comment">;</span>
            p -= TETRIS_COL_NUMS<span class="comment">;</span>
            while(p &gt;= tetris.units &amp;&amp; !p-&gt;fill) {p -= TETRIS_COL_NUMS<span class="comment">; }    </span>

            tetris.pool.push_back(p+TETRIS_COL_NUMS)<span class="comment">;</span>

            j = 0<span class="comment">;</span>
            while(j++ &lt; i){
                p += TETRIS_COL_NUMS<span class="comment">;</span>
                q += TETRIS_COL_NUMS<span class="comment">; </span>
                (*p)=(*q)<span class="comment">;</span>
                p-&gt;fill = 2<span class="comment">;</span>
                q-&gt;fill = 0<span class="comment">;</span>
            }    

            cnt++<span class="comment">;</span>
        }        
    }

    if(pool-&gt;size() &gt; 0) pool-&gt;clear()<span class="comment">;</span>

    if(cnt) return<span class="comment">;</span>

    pool = &amp;tetris.pool<span class="comment">;</span>

    for(cnt = 0,iter=pool-&gt;begin()<span class="comment">;iter != pool-&gt;end(); iter++)</span>
    {
        unitData *p,*pthis<span class="comment">;</span>

        GLint nums[4]={0},num=0<span class="comment">; //bottom,left,right,above</span>
        GLint thiscol,thisrow,index<span class="comment">;</span>

        p = pthis = (*iter)<span class="comment">;</span>

        index = p - tetris.units<span class="comment">;</span>
        thiscol = index % TETRIS_COL_NUMS<span class="comment">;</span>
        thisrow = index / TETRIS_COL_NUMS<span class="comment">;</span>

        //bottom
        i = 0<span class="comment">;</span>
        row = thisrow - 1<span class="comment">;</span>
        col = thiscol<span class="comment">;</span>
        p = &amp;pa[row][col]<span class="comment">;</span>
        while(row &gt;= 0 &amp;&amp; p-&gt;fill &amp;&amp; p-&gt;color == pthis-&gt;color) { nums[0]++<span class="comment">; p = &amp;pa[--row][col]; }</span>

        //left
        i = 0<span class="comment">;</span>
        row = thisrow<span class="comment">;</span>
        col = thiscol - 1<span class="comment">;</span>
        p = &amp;pa[row][col]<span class="comment">;</span>
        while(col &gt;= 0 &amp;&amp; p-&gt;fill &amp;&amp; p-&gt;color == pthis-&gt;color) { nums[1]++<span class="comment">; p = &amp;pa[row][--col]; }</span>

        //right
        i = 0<span class="comment">;</span>
        row = thisrow<span class="comment">;</span>
        col = thiscol + 1<span class="comment">;</span>
        p = &amp;pa[row][col]<span class="comment">;</span>
        while(col &lt; TETRIS_COL_NUMS &amp;&amp; p-&gt;fill &amp;&amp; p-&gt;color == pthis-&gt;color) { nums[2]++<span class="comment">; p = &amp;pa[row][++col]; }</span>

        //above
        i = 0<span class="comment">;</span>
        row = thisrow + 1<span class="comment">;</span>
        col = thiscol<span class="comment">;</span>
        p = &amp;pa[row][col]<span class="comment">;</span>
        while(row &lt; TETRIS_ROW_NUMS &amp;&amp; p-&gt;fill &amp;&amp; p-&gt;color == pthis-&gt;color) { 
            nums[3]++<span class="comment">; p = &amp;pa[++row][col]; </span>
        }

        num = nums[0] + nums[3] + 1<span class="comment">;</span>
        if(num &gt;= 4){
            p = pthis - nums[0] * TETRIS_COL_NUMS<span class="comment">;</span>
            for(i = 0<span class="comment">; i &lt; num; i++){</span>
                p-&gt;fill = 0<span class="comment">;</span>
                p += TETRIS_COL_NUMS<span class="comment">;</span>
            }

            tetris.score += 5*num<span class="comment">;</span>

            p = p-TETRIS_COL_NUMS<span class="comment">;</span>

            unitPos *pos=tetris.CurUnitsPos<span class="comment">;</span>

            if(p == &amp;pa[pos[0].row][pos[0].col]
                || p == &amp;pa[pos[0].row][pos[0].col]){}
            else{                
                tetris.poolex.push_back(p)<span class="comment">;</span>
                cnt++<span class="comment">;</span>
            }
        }

        num = nums[1] + nums[2] + 1<span class="comment">;</span>
        if(num &gt;= 4){            
            p = pthis - nums[1]<span class="comment">;        </span>
            for(i = 0<span class="comment">; i &lt; num; i++){</span>
                tetris.poolex.push_back(p)<span class="comment">;</span>
                p-&gt;fill = 0<span class="comment">;                </span>
                p++<span class="comment">;</span>
            }    
            tetris.score += 5*num<span class="comment">;</span>
            cnt++<span class="comment">;</span>
        }
    }

    if((tetris.score - tetris.scoreLastLevel) &gt; 50 + (tetris.level) * 10){
        tetris.updateLevel = 128<span class="comment">;</span>
        tetris.level++<span class="comment">;</span>
        tetris.scoreLastLevel = tetris.score<span class="comment">;</span>
        tetris.frequencymax -= 2<span class="comment">;</span>
        if(tetris.frequencymax &lt; 1) tetris.frequencymax = 1<span class="comment">;</span>
    }

    if(0 == cnt) {
        tetris.updating = 0<span class="comment">;</span>
        for(i = 0<span class="comment">; i &lt; 2; i++)</span>
            if(!pa[tetris.CurUnitsPos[i].row][tetris.CurUnitsPos[i].col].fill) 
                tetris.CurUnits[i].stat = 1<span class="comment">;</span>
    }
    else tetris.updating++<span class="comment">;</span>

}


//Timer, 
GLvoid OnTimer(int time)
{
    unitData *p=tetris.CurUnits<span class="comment">;</span>

    GLboolean flag=0<span class="comment">;</span>

    if(++tetris.gamecount == 30000)
        tetris.gamecount = 0<span class="comment">;</span>

    if(tetris.gamepause
        ||tetris.gameover
        || tetris.levelStart
        || tetris.delay) 
    {
        glutTimerFunc(5, OnTimer, 1)<span class="comment">;        </span>
        glutPostRedisplay()<span class="comment">;</span>
        if(tetris.delay &gt; 0){
            tetris.delay--<span class="comment">;</span>
            if(tetris.delay == 0){
                if(tetris.levelStart==1){
                    tetris.levelStart = 0<span class="comment">;</span>
                    //tetris.gameover = 1<span class="comment">;</span>
                    //tetris.delay = TETRIS_DELAY_TIME<span class="comment">;</span>
                    //tetris.levelStart = 2<span class="comment">;</span>

                    return<span class="comment">;</span>
                }

                if(tetris.gameover){
                    tetris.gameover = 0<span class="comment">;</span>
                    tetris.levelStart = 2<span class="comment">;</span>
                    tetris.waitUserTextSy = 0<span class="comment">;</span>
                    return<span class="comment">;</span>
                }
            }
        }
        return<span class="comment">;</span>
    }

    switch(tetris.CurUnitsStat)
    {

    case 0:        
        Tetris_InitTwoUnits(p)<span class="comment">;</span>
        break<span class="comment">;</span>
    case 1:
        if(!tetris.updating)
            flag = Tetris_TwoUnitsFunc(p)<span class="comment">;</span>
        break<span class="comment">;</span>
    case 2:    
        tetris.CurUnitsStat = 0<span class="comment">;    </span>
        break<span class="comment">;</span>
    }

    glutPostRedisplay()<span class="comment">;    </span>
    glutTimerFunc(5, OnTimer, 1)<span class="comment">;</span>

    if(!flag &amp;&amp; tetris.updating)        
        Tetris_Update()<span class="comment">;    </span>
    tetris.frequency = tetris.frequencymax<span class="comment">;    </span>
}

GLvoid idle()
{

}

GLvoid Tetris_InitParam(void)
{
    tetris.level = 1<span class="comment">;</span>
    tetris.score = 0<span class="comment">;</span>
    tetris.levelStart = 1<span class="comment">;</span>
    tetris.frequencymax = TETRIS_FREQUENCY_MAX<span class="comment">;</span>
    tetris.frequency = tetris.frequencymax<span class="comment">;</span>
    tetris.delay = TETRIS_DELAY_TIME<span class="comment">;</span>
    tetris.CurUnitsStat = 0<span class="comment">;</span>
    memset(tetris.CurUnits,0,sizeof(tetris.CurUnits))<span class="comment">;</span>
    memset(tetris.CurUnitsPos,0,sizeof(tetris.CurUnitsPos))<span class="comment">;</span>
    memset(tetris.units,0,sizeof(tetris.units))<span class="comment">;</span>
    tetris.scoreLastLevel = 0<span class="comment">;</span>
}


//Init game.
GLvoid initgame()
{
    LoadGLTextures()<span class="comment">;    </span>
    glEnable(GL_TEXTURE_2D)<span class="comment">;</span>
    glAlphaFunc(GL_GREATER, 0.1f)<span class="comment">;    </span>
    glEnable (GL_BLEND)<span class="comment">;</span>
    glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)<span class="comment">;</span>
    glShadeModel (GL_FLAT)<span class="comment">;    </span>
    Tetris_InitParam()<span class="comment">;    </span>
}

GLint main(GLint argc,char** argv)
{
    glutInit(&amp;argc, argv)<span class="comment">;</span>
    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGBA)<span class="comment">;</span>
    glutInitWindowPosition(<span class="number">100,100</span>)<span class="comment">;</span>
    glutInitWindowSize(TETRIS_SCREEN_WIDTH,TETRIS_SCREEN_HEIGHT)<span class="comment">;    </span>
    tetris.mainWindow = glutCreateWindow(appName)<span class="comment">;    </span>
    glutReshapeFunc(changeWindow)<span class="comment">;</span>
    glutDisplayFunc(render)<span class="comment">;</span>
    glutKeyboardFunc(keys)<span class="comment">;</span>
    glutSpecialFunc(specialKeysPressed)<span class="comment">;</span>
    glutSetCursor(GLUT_CURSOR_NONE)<span class="comment">;</span>
    glutTimerFunc(5,OnTimer,1)<span class="comment">;</span>
    glutIdleFunc(idle)<span class="comment">;</span>

    initgame()<span class="comment">;</span>

    glutMainLoop()<span class="comment">;    </span>
    return 0<span class="comment">;</span>
}
</code></pre>
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





<nav id="pagination">
  
  
    <a href="/page/2/" class="alignright next">下一页</a>
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:yoursite.com">
  </form>
</div>

  

  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/C/">C++</a><small>9</small></li>
  
    <li><a href="/tags/DB/">DB</a><small>1</small></li>
  
    <li><a href="/tags/HTTP/">HTTP</a><small>1</small></li>
  
    <li><a href="/tags/Linux/">Linux</a><small>1</small></li>
  
    <li><a href="/tags/单词/">单词</a><small>1</small></li>
  
    <li><a href="/tags/博客/">博客</a><small>9</small></li>
  
    <li><a href="/tags/技术/">技术</a><small>8</small></li>
  
    <li><a href="/tags/文章/">文章</a><small>9</small></li>
  
    <li><a href="/tags/源代码/">源代码</a><small>1</small></li>
  
    <li><a href="/tags/转载/">转载</a><small>1</small></li>
  
  </ul>
</div>


  
<div class="widget tagcloud">
  <h3 class="title">标签云</h3>
  <div class="entry">
    <a href="/tags/C/" style="font-size: 20px;">C++</a> <a href="/tags/DB/" style="font-size: 10px;">DB</a> <a href="/tags/HTTP/" style="font-size: 10px;">HTTP</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/单词/" style="font-size: 10px;">单词</a> <a href="/tags/博客/" style="font-size: 20px;">博客</a> <a href="/tags/技术/" style="font-size: 15px;">技术</a> <a href="/tags/文章/" style="font-size: 20px;">文章</a> <a href="/tags/源代码/" style="font-size: 10px;">源代码</a> <a href="/tags/转载/" style="font-size: 10px;">转载</a>
  </div>
</div>


  <div class="widget tag">
<h3 class="title">友情链接</h3>
<ul class="entry">
<li><a href="http://zipperary.com/" title="Zippera's Blog">Zippera</a></li>
</ul>
</div>

  <iframe width="100%" height="550" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=550&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=1&isFans=1&uid=1235899094&verifier=a6902c2e&dpc=1"></iframe>
</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2016 shafeng
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>