<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Shafeng`s blog</title>
  <meta name="author" content="shafeng">
  
  <meta name="description" content="c++">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="Shafeng`s blog"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.ico" rel="icon" type="image/x-ico">
  <link rel="alternate" href="/atom.xml" title="Shafeng`s blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Shafeng`s blog</a></h1>
  <h2><a href="/">road</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">首页</a></li>
    
      <li><a href="/archives">目录</a></li>
    
      <li><a href="/about">关于</a></li>
    
	<li> <a href="/atom.xml">RSS</a> </li>
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-05-07T04:00:00.000Z"><a href="/2018/05/07/codis_1/">2018-05-07</a></time>
      
      
  
    <h1 class="title"><a href="/2018/05/07/codis_1/">codis_1</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="Redis集群，Codis的安装和使用">Redis集群，Codis的安装和使用</h2><p>项目上经过了多次合服和长达两年多的运营，单服玩家已经超过了600W,项目最原始的架构是将所有玩家的摘要数据在服务器启动时从数据库中读取，如果只有几万人或者及几十万人，启动速度基本上就是一两分钟的样子，没有什么压力，但是600W玩家的所有摘要数据全部加载需要的时间可能超过几十分钟，为此项目使用了Redis，将玩家摘要数据和排行榜数据全部都转移到了Redis中，我使用了Codis，基于go开发的redis集群，可以无限扩展Redis的内存大小。记录一下部署和使用Codis的全过程。</p>
<p><img src="../img/codis.png" alt="Codis"></p>
<h3 id="安装环境">安装环境</h3><p>codis-proxy相当于redis，即连接codis-proxy和连接redis是没有任何区别的，codis-proxy无状态，不负责记录是否在哪保存，数据在zookeeper记录，即codis proxy向zookeeper查询key的记录位置，proxy 将请求转发到一个组进行处理，一个组里面有一个master和一个或者多个slave组成，默认有1024个槽位，其把不同的槽位的内容放在不通的group。codis是基于go语言编写的，因此要安装go语言环境。每台服务器安装java环境和zookeeper，zookeeper集群最少需要3台服务器。</p>
<h4 id="安装_zookeeper">安装 zookeeper</h4><pre><code>wget http:<span class="comment">//219.238.7.67/files/205200000AF1D7B9/mirrors.hust.edu.cn/apache/zookeeper/zookeeper-3.4.11/zookeeper-3.4.11.tar.gz</span>
tar -xzf zookeeper-<span class="number">3.4</span>.<span class="number">11</span><span class="class">.tar</span><span class="class">.gz</span> -C /data/service
</code></pre><h4 id="安装_java">安装 java</h4><pre><code>tar zxf jdk-<span class="number">8u</span>131-linux-x64.gz
mv jdk1<span class="number">.8</span><span class="number">.0</span>_131 /usr/local/
</code></pre><h4 id="安装_go_编译环境">安装 go 编译环境</h4><pre><code># cd /usr/local/src
[root@node1 src]# yum <span class="operator"><span class="keyword">install</span> -y gcc glibc gcc-<span class="keyword">c</span>++ make git
[root@node1 src]# wget https://<span class="keyword">storage</span>.googleapis.com/golang/go1<span class="number">.7</span><span class="number">.3</span>.linux-amd64.tar.gz
[root@node1 src]# tar zxf go1<span class="number">.7</span><span class="number">.3</span>.linux-amd64.tar.gz
[root@node1 src]# mv <span class="keyword">go</span> /usr/<span class="keyword">local</span>/
[root@node1 src]# mkdir /usr/<span class="keyword">local</span>/<span class="keyword">go</span>/<span class="keyword">work</span>
[root@node1 src]# vim /root/.bash_profile

<span class="keyword">export</span> <span class="keyword">PATH</span>=$<span class="keyword">PATH</span>:/usr/<span class="keyword">local</span>/<span class="keyword">go</span>/<span class="keyword">bin</span>
<span class="keyword">export</span> GOROOT=/usr/<span class="keyword">local</span>/<span class="keyword">go</span>
<span class="keyword">export</span> GOPATH=/usr/<span class="keyword">local</span>/<span class="keyword">go</span>/<span class="keyword">work</span>
<span class="keyword">path</span>=$<span class="keyword">PATH</span>:$HOME/<span class="keyword">bin</span>:$GOROOT/<span class="keyword">bin</span>:$GOPATH/<span class="keyword">bin</span>
[root@node1 src]# <span class="keyword">source</span> /root/.bash_profile

[root@node1 src]# echo $GOPATH
/usr/<span class="keyword">local</span>/<span class="keyword">go</span>/<span class="keyword">work</span>
[root@node1 ~]# <span class="keyword">go</span> <span class="keyword">version</span>
<span class="keyword">go</span> <span class="keyword">version</span> go1<span class="number">.7</span><span class="number">.3</span> linux/amd64</span>
</code></pre><h4 id="zookeeper配置文件">zookeeper配置文件</h4><pre><code><span class="preprocessor"># 中使用的基本时间单位, 毫秒值.</span>
tickTime=<span class="number">2000</span>
<span class="preprocessor"># follower和leader之间的最长心跳时间 initLimit * tickTime 毫秒超时</span>
initLimit=<span class="number">10</span>
<span class="preprocessor"># </span>
<span class="preprocessor"># follower和leader之间 同步数据的最大时间 syncLimit * tickTime 毫秒超时</span>
syncLimit=<span class="number">5</span>
<span class="preprocessor"># 数据目录. 可以是任意目录.</span>
dataDir=/data/service/zookeeper-data/data
<span class="preprocessor"># log目录</span>
dataLogDir=/data/service/zookeeper-data/logs
<span class="preprocessor"># 防止启动失败一个配置，不知道干啥的</span>
quorumListenOnAllIPs=<span class="literal">true</span>
<span class="preprocessor"># 监听client连接的端口号.</span>
clientPort=<span class="number">19021</span>
<span class="preprocessor"># 客户端连接的最大数量。</span>
<span class="preprocessor">#maxClientCnxns=<span class="number">60</span></span>
<span class="preprocessor"># 维护相关的</span>
<span class="preprocessor">#autopurge.snapRetainCount=<span class="number">3</span></span>
<span class="preprocessor">#autopurge.purgeInterval=<span class="number">1</span></span>

server<span class="number">.1</span> = <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">19022</span>:<span class="number">19029</span>
server<span class="number">.2</span> = <span class="number">172.31</span><span class="number">.0</span><span class="number">.17</span>:<span class="number">19022</span>:<span class="number">19029</span>
server<span class="number">.3</span> = <span class="number">172.31</span><span class="number">.0</span><span class="number">.79</span>:<span class="number">19022</span>:<span class="number">19029</span>
</code></pre><p>详细解释：<br>            tickTime：这个时间是作为 Zookeeper 服务器之间或客户端与服务器之间维持心跳的时间间隔，也就是每个 tickTime 时间就会发送一个心跳。<br>            dataDir：顾名思义就是 Zookeeper 保存数据的目录，默认情况下，Zookeeper 将写数据的日志文件也保存在这个目录里。<br>            clientPort：这个端口就是客户端连接 Zookeeper 服务器的端口，Zookeeper 会监听这个端口，接受客户端的访问请求。<br>            initLimit：这个配置项是用来配置 Zookeeper 接受客户端（这里所说的客户端不是用户连接 Zookeeper 服务器的客户端，而是 Zookeeper 服务器集群中连接到 Leader 的 Follower 服务器）初始化连接时最长能忍受多少个心跳时间间隔数。当已经超过 5个心跳的时间（也就是 tickTime）长度后 Zookeeper 服务器还没有收到客户端的返回信息，那么表明这个客户端连接失败。总的时间长度就是 10<em>6000=60 秒<br>            syncLimit：这个配置项标识 Leader 与 Follower 之间发送消息，请求和应答时间长度，最长不能超过多少个 tickTime 的时间长度，总的时间长度就是 5</em>6000=30 秒<br>            server.A=B：C：D：其中 A 是一个数字，表示这个是第几号服务器；B 是这个服务器的 ip 地址；C 表示的是这个服务器与集群中的 Leader 服务器交换信息的端口；D 表示的是万一集群中的 Leader 服务器挂了，需要一个端口来重新进行选举，选出一个新的 Leader，而这个端口就是用来执行选举时服务器相互通信的端口。如果是伪集群的配置方式，由于 B 都是一样，所以不同的 Zookeeper 实例通信端口号不能一样，所以要给它们分配不同的端口号。</p>
<p>启动zookeeper</p>
<pre><code><span class="regexp">/data/</span>service<span class="regexp">/zookeeper-3.4.11/</span>bin<span class="regexp">/zkServer.sh  /</span>data<span class="regexp">/service/</span>zookeeper-<span class="number">3.4</span>.<span class="number">11</span><span class="regexp">/conf/</span>zoo.cfg
</code></pre><h3 id="安装部署codis">安装部署codis</h3><h4 id="下载编译codis3-2版本">下载编译codis3.2版本</h4><p>我直接使用了编译好的一个版本</p>
<h4 id="codis配置文件">codis配置文件</h4><hr>
<font color="#FF6347">/codis/config/dashboard.toml</font>

<pre><code><span class="comment">##################################################</span>
<span class="comment">#                                                #</span>
<span class="comment">#                  Codis-Dashboard               #</span>
<span class="comment">#                                                #</span>
<span class="comment">##################################################</span>

<span class="comment"># Set Coordinator, only accept "zookeeper" &amp; "etcd" &amp; "filesystem".</span>
<span class="comment"># for zookeeper/etcd, coorinator_auth accept "user:password" </span>
<span class="comment"># Quick Start</span>
<span class="comment">#coordinator_name = "filesystem"</span>
<span class="comment">#coordinator_addr = "/tmp/codis"</span>
<span class="setting">coordinator_name = <span class="value"><span class="string">"zookeeper"</span></span></span>
<span class="setting">coordinator_addr = <span class="value"><span class="string">"172.31.0.84:19021"</span></span></span>
<span class="comment">#coordinator_auth = ""</span>

<span class="comment"># Set Codis Product Name/Auth.</span>
<span class="setting">product_name = <span class="value"><span class="string">"codis-warship"</span></span></span>
<span class="setting">product_auth = <span class="value"><span class="string">""</span></span></span>

<span class="comment"># Set bind address for admin(rpc), tcp only.</span>
<span class="setting">admin_addr = <span class="value"><span class="string">"0.0.0.0:18080"</span></span></span>

<span class="comment"># Set arguments for data migration (only accept 'sync' &amp; 'semi-async').</span>
<span class="setting">migration_method = <span class="value"><span class="string">"semi-async"</span></span></span>
<span class="setting">migration_parallel_slots = <span class="value"><span class="number">100</span></span></span>
<span class="setting">migration_async_maxbulks = <span class="value"><span class="number">200</span></span></span>
<span class="setting">migration_async_maxbytes = <span class="value"><span class="string">"32mb"</span></span></span>
<span class="setting">migration_async_numkeys = <span class="value"><span class="number">500</span></span></span>
<span class="setting">migration_timeout = <span class="value"><span class="string">"30s"</span></span></span>

<span class="comment"># Set configs for redis sentinel.</span>
<span class="setting">sentinel_client_timeout = <span class="value"><span class="string">"10s"</span></span></span>
<span class="setting">sentinel_quorum = <span class="value"><span class="number">2</span></span></span>
<span class="setting">sentinel_parallel_syncs = <span class="value"><span class="number">1</span></span></span>
<span class="setting">sentinel_down_after = <span class="value"><span class="string">"30s"</span></span></span>
<span class="setting">sentinel_failover_timeout = <span class="value"><span class="string">"5m"</span></span></span>
<span class="setting">sentinel_notification_script = <span class="value"><span class="string">""</span></span></span>
<span class="setting">sentinel_client_reconfig_script = <span class="value"><span class="string">""</span></span></span>
</code></pre><p>启动dashboard：</p>
<pre><code>[root<span class="variable">@node1</span> codis]# nohup ./bin/codis-dashboard --ncpu=<span class="number">1</span> --config=config/dashboard.toml --<span class="keyword">log</span>=dashboard.<span class="keyword">log</span> --<span class="keyword">log</span>-level=WARN &gt;&gt; /var/<span class="keyword">log</span>/codis_dashboard.<span class="keyword">log</span> &amp;
</code></pre><hr>
<font color="#FF6347">/codis/config/proxy.toml</font>


<pre><code>##################################################
#                                                #
#                  Codis-Proxy                   #
#                                                #
##################################################

# <span class="operator"><span class="keyword">Set</span> Codis Product <span class="keyword">Name</span>/Auth.
product_name = <span class="string">"codis-warship"</span>
product_auth = <span class="string">""</span>

# <span class="keyword">Set</span> auth <span class="keyword">for</span> <span class="keyword">client</span> <span class="keyword">session</span>
#   <span class="number">1.</span> product_auth <span class="keyword">is</span> used <span class="keyword">for</span> auth <span class="keyword">validation</span> among codis-dashboard,
#      codis-proxy <span class="keyword">and</span> codis-<span class="keyword">server</span>.
#   <span class="number">2.</span> session_auth <span class="keyword">is</span> different <span class="keyword">from</span> product_auth, it requires clients
#      <span class="keyword">to</span> issue AUTH &lt;<span class="keyword">PASSWORD</span>&gt; <span class="keyword">before</span> processing <span class="keyword">any</span> other commands.
session_auth = <span class="string">""</span>

# <span class="keyword">Set</span> bind address <span class="keyword">for</span> <span class="keyword">admin</span>(rpc), tcp <span class="keyword">only</span>.
admin_addr = <span class="string">"0.0.0.0:11080"</span>

# <span class="keyword">Set</span> bind address <span class="keyword">for</span> proxy, proto_type can be <span class="string">"tcp"</span>, <span class="string">"tcp4"</span>, <span class="string">"tcp6"</span>, <span class="string">"unix"</span> <span class="keyword">or</span> <span class="string">"unixpacket"</span>.
proto_type = <span class="string">"tcp4"</span>
proxy_addr = <span class="string">"0.0.0.0:19000"</span>

# <span class="keyword">Set</span> jodis address &amp; <span class="keyword">session</span> <span class="keyword">timeout</span>
#   <span class="number">1.</span> jodis_name <span class="keyword">is</span> <span class="keyword">short</span> <span class="keyword">for</span> jodis_coordinator_name, <span class="keyword">only</span> <span class="keyword">accept</span> <span class="string">"zookeeper"</span> &amp; <span class="string">"etcd"</span>.
#   <span class="number">2.</span> jodis_addr <span class="keyword">is</span> <span class="keyword">short</span> <span class="keyword">for</span> jodis_coordinator_addr
#   <span class="number">3.</span> jodis_auth <span class="keyword">is</span> <span class="keyword">short</span> <span class="keyword">for</span> jodis_coordinator_auth, <span class="keyword">for</span> zookeeper/etcd, <span class="string">"user:password"</span> <span class="keyword">is</span> accepted.
#   <span class="number">4.</span> proxy will be registered <span class="keyword">as</span> node:
#        <span class="keyword">if</span> jodis_compatible = <span class="literal">true</span> (<span class="keyword">not</span> suggested):
#          /zk/codis/db_{PRODUCT_NAME}/proxy-{HASHID} (compatible <span class="keyword">with</span> Codis2<span class="number">.0</span>)
#        <span class="keyword">or</span> <span class="keyword">else</span>
#          /jodis/{PRODUCT_NAME}/proxy-{HASHID}
jodis_name = <span class="string">"zookeeper"</span>
jodis_addr = <span class="string">"172.31.0.84:19021,172.31.0.17:19021,172.31.0.79:19021"</span>
jodis_auth = <span class="string">""</span>
jodis_timeout = <span class="string">"20s"</span>
jodis_compatible = <span class="literal">true</span>

# <span class="keyword">Set</span> datacenter <span class="keyword">of</span> proxy.
proxy_datacenter = <span class="string">""</span>

# <span class="keyword">Set</span> <span class="keyword">max</span> <span class="built_in">number</span> <span class="keyword">of</span> alive sessions.
proxy_max_clients = <span class="number">1000</span>

# <span class="keyword">Set</span> <span class="keyword">max</span> offheap <span class="keyword">memory</span> <span class="keyword">size</span>. (<span class="number">0</span> <span class="keyword">to</span> <span class="keyword">disable</span>)
proxy_max_offheap_size = <span class="string">"1024mb"</span>

# <span class="keyword">Set</span> <span class="keyword">heap</span> placeholder <span class="keyword">to</span> reduce GC frequency.
proxy_heap_placeholder = <span class="string">"256mb"</span>

# Proxy will ping backend redis (<span class="keyword">and</span> <span class="keyword">clear</span> <span class="string">'MASTERDOWN'</span> state) <span class="keyword">in</span> a predefined <span class="built_in">interval</span>. (<span class="number">0</span> <span class="keyword">to</span> <span class="keyword">disable</span>)
backend_ping_period = <span class="string">"5s"</span>

# <span class="keyword">Set</span> backend recv buffer <span class="keyword">size</span> &amp; <span class="keyword">timeout</span>.
backend_recv_bufsize = <span class="string">"128kb"</span>
backend_recv_timeout = <span class="string">"30s"</span>

# <span class="keyword">Set</span> backend send buffer &amp; <span class="keyword">timeout</span>.
backend_send_bufsize = <span class="string">"128kb"</span>
backend_send_timeout = <span class="string">"30s"</span>

# <span class="keyword">Set</span> backend pipeline buffer <span class="keyword">size</span>.
backend_max_pipeline = <span class="number">20480</span>

# <span class="keyword">Set</span> backend <span class="keyword">never</span> <span class="keyword">read</span> replica <span class="keyword">groups</span>, <span class="keyword">default</span> <span class="keyword">is</span> <span class="literal">false</span>
backend_primary_only = <span class="literal">false</span>

# <span class="keyword">Set</span> backend <span class="keyword">parallel</span> connections per <span class="keyword">server</span>
backend_primary_parallel = <span class="number">1</span>
backend_replica_parallel = <span class="number">1</span>

# <span class="keyword">Set</span> backend tcp keepalive <span class="keyword">period</span>. (<span class="number">0</span> <span class="keyword">to</span> <span class="keyword">disable</span>)
backend_keepalive_period = <span class="string">"75s"</span>

# <span class="keyword">Set</span> <span class="built_in">number</span> <span class="keyword">of</span> <span class="keyword">databases</span> <span class="keyword">of</span> backend.
backend_number_databases = <span class="number">16</span>

# <span class="keyword">If</span> there <span class="keyword">is</span> <span class="keyword">no</span> request <span class="keyword">from</span> <span class="keyword">client</span> <span class="keyword">for</span> a <span class="keyword">long</span> <span class="keyword">time</span>, the <span class="keyword">connection</span> will be closed. (<span class="number">0</span> <span class="keyword">to</span> <span class="keyword">disable</span>)
# <span class="keyword">Set</span> <span class="keyword">session</span> recv buffer <span class="keyword">size</span> &amp; <span class="keyword">timeout</span>.
session_recv_bufsize = <span class="string">"128kb"</span>
session_recv_timeout = <span class="string">"30m"</span>

# <span class="keyword">Set</span> <span class="keyword">session</span> send buffer <span class="keyword">size</span> &amp; <span class="keyword">timeout</span>.
session_send_bufsize = <span class="string">"64kb"</span>
session_send_timeout = <span class="string">"30s"</span>

# Make sure this <span class="keyword">is</span> higher <span class="keyword">than</span> the <span class="keyword">max</span> <span class="built_in">number</span> <span class="keyword">of</span> requests <span class="keyword">for</span> <span class="keyword">each</span> pipeline request, <span class="keyword">or</span> your <span class="keyword">client</span> may be blocked.
# <span class="keyword">Set</span> <span class="keyword">session</span> pipeline buffer <span class="keyword">size</span>.
session_max_pipeline = <span class="number">10000</span>

# <span class="keyword">Set</span> <span class="keyword">session</span> tcp keepalive <span class="keyword">period</span>. (<span class="number">0</span> <span class="keyword">to</span> <span class="keyword">disable</span>)
session_keepalive_period = <span class="string">"75s"</span>

# <span class="keyword">Set</span> <span class="keyword">session</span> <span class="keyword">to</span> be sensitive <span class="keyword">to</span> failures. <span class="keyword">Default</span> <span class="keyword">is</span> <span class="literal">false</span>, instead <span class="keyword">of</span> closing socket, proxy will send an <span class="keyword">error</span> response <span class="keyword">to</span> <span class="keyword">client</span>.
session_break_on_failure = <span class="literal">false</span>

# <span class="keyword">Set</span> metrics <span class="keyword">server</span> (such <span class="keyword">as</span> <span class="keyword">http</span>://localhost:<span class="number">28000</span>), proxy will report <span class="keyword">json</span> formatted metrics <span class="keyword">to</span> specified <span class="keyword">server</span> <span class="keyword">in</span> a predefined <span class="keyword">period</span>.
metrics_report_server = <span class="string">""</span>
metrics_report_period = <span class="string">"1s"</span>

# <span class="keyword">Set</span> influxdb <span class="keyword">server</span> (such <span class="keyword">as</span> <span class="keyword">http</span>://localhost:<span class="number">8086</span>), proxy will report metrics <span class="keyword">to</span> influxdb.
metrics_report_influxdb_server = <span class="string">""</span>
metrics_report_influxdb_period = <span class="string">"1s"</span>
metrics_report_influxdb_username = <span class="string">""</span>
metrics_report_influxdb_password = <span class="string">""</span>
metrics_report_influxdb_database = <span class="string">""</span>

# <span class="keyword">Set</span> statsd <span class="keyword">server</span> (such <span class="keyword">as</span> localhost:<span class="number">8125</span>), proxy will report metrics <span class="keyword">to</span> statsd.
metrics_report_statsd_server = <span class="string">""</span>
metrics_report_statsd_period = <span class="string">"1s"</span>
metrics_report_statsd_prefix = <span class="string">""</span></span>
</code></pre><p>启动代理</p>
<pre><code>[root<span class="variable">@node1</span> codis]# nohup ./bin/codis-proxy --ncpu=<span class="number">1</span> --config=config/proxy.toml --<span class="keyword">log</span>=proxy.<span class="keyword">log</span> --<span class="keyword">log</span>-level=WARN &gt;&gt; /var/<span class="keyword">log</span>/codis_proxy.<span class="keyword">log</span> &amp;
</code></pre><hr>
<p><font color="#FF6347">/codis/config/redis-6380.conf</font>   redis的配置主要是改这几个</p>
<pre><code>bind <span class="number">172.31</span><span class="number">.0</span><span class="number">.84</span>
port <span class="number">6380</span>
pidfile <span class="string">"/tmp/redis_6380.pid"</span>
maxmemory <span class="number">12</span>G
dir <span class="string">"/data/service/codis"</span>
logfile <span class="string">"/tmp/redis_6380.log"</span>
</code></pre><p>通过codis-server指定redis.conf文件启动redis服务，不能通过redis命令启动redis服务，通过redis启动的redis 服务加到codis集群无法正常使用：</p>
<pre><code>[root<span class="constant">@redis1</span> codis]<span class="preprocessor"># ./bin/codis-server ../config/redis_6380.conf </span>
</code></pre><h3 id="使用codis的网页服务器配置codis服务器">使用codis的网页服务器配置codis服务器</h3><p>启动codis-fe</p>
<pre><code>nohup ./bin/codis-fe --ncpu=<span class="number">1</span> --<span class="built_in">log</span>=fe.<span class="built_in">log</span> --<span class="built_in">log</span>-level=WARN --zookeeper=<span class="number">172.31</span><span class="number">.0</span><span class="number">.84</span>:<span class="number">19021</span> --listen=<span class="number">172.31</span><span class="number">.0</span><span class="number">.84</span>:<span class="number">8060</span>
</code></pre>
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2017-06-27T07:46:53.000Z"><a href="/2017/06/27/gstack_strace/">2017-06-27</a></time>
      
      
  
    <h1 class="title"><a href="/2017/06/27/gstack_strace/">gstack,strace,gcore(Linux)</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="关于Linux程序运行中查看堆栈的一些命令">关于Linux程序运行中查看堆栈的一些命令</h2><pre><code>最近项目上遇到一些问题，服务器程序在运行的时候cpu特别高，尤其是逻辑线程，一度达到<span class="number">99</span>%。为了查找问题，使用了一些之前没有用过的命令，加上我之前用过的几个命令，写一篇记录
</code></pre><h3 id="gstack">gstack</h3><pre><code>gstack 线程<span class="property">id</span>,例如:gstack <span class="number">2939</span>,可以查看到当前线程的堆栈信息,如果程序的当前线程占cpu特别高,可能会出现死循环或者其他症状,我们可以通过使用gstack命令查看当前线程的堆栈信息来诊断问题.
</code></pre><h3 id="strace">strace</h3><pre><code>strace -T -r -c -<span class="tag">p</span> 线程id,例如:strace -T -r -c -<span class="tag">p</span> <span class="number">2939</span>,可以得到当前线程的所有系统调用统计,停止统计的时候必须自己手动退出,会输出使用命令到停止统计期间的信息.
</code></pre><h3 id="gcore">gcore</h3><pre><code>gcore 进程<span class="property">id</span>,例如:gcore <span class="number">12345</span>,可以得到当前进程的所有线程的堆栈信息.
</code></pre><p>一些总结,通过以上这些命令可以间接观察到程序当前的运行状态和运行位置.给予程序开发者更多的讯息以诊断程序当前可能出现的问题,有一个需要注意的地方,gstack和strace在运行期间不会影响到程序本身的运行,而gcore会将程序暂停,影响程序的正常工作.</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2017-06-10T04:00:00.000Z"><a href="/2017/06/10/mysql/">2017-06-10</a></time>
      
      
  
    <h1 class="title"><a href="/2017/06/10/mysql/">mysql</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="Mysql的一些性能优化记录">Mysql的一些性能优化记录</h2><p>项目上经过合服等操作,单服的玩家数量一度超过500W,一些排行榜数据和玩家摘要数据在程序启动时就要从数据库中加载,数据量的增大也延长了服务器程序的启动时间,一些必要的优化就在所难免了.贴一下数据的配置.做一下记录</p>
<pre><code>[client]
<span class="constant">socket</span> = /tmp/mysql.sock


[mysqld_multi]
<span class="constant">log</span>        = /data/mysql_db/mysqld_multi.log
<span class="constant">mysqld</span>     = /usr/bin/mysqld_safe
<span class="constant">mysqladmin</span> = /usr/bin/mysqladmin
<span class="constant">user</span>       = shutdown_user

<span class="comment">###########################################################################################</span>
[mysqld4306]
<span class="constant">port</span>       = 4306
<span class="constant">socket</span>     = /tmp/mysql_4306.sock
pid-file   = /tmp/mysql_4306.pid
<span class="constant">datadir</span>    = /data/mysql_db/4306
<span class="constant">default_storage_engine</span> = InnoDB
<span class="constant">sql_mode</span>=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES
skip-name-resolve
<span class="constant">max_connections</span> = 1000
<span class="constant">innodb_flush_log_at_trx_commit</span> = 2
<span class="constant">innodb_flush_log_at_timeout</span>     =1
<span class="constant">innodb_buffer_pool_size</span> = 24080M
<span class="constant">innodb_log_buffer_size</span> = 8M
<span class="constant">innodb_log_file_size</span> = 256M
log-bin=/data/mysql_binlog/4306/mysql-bin
<span class="constant">binlog_format</span>=MIXED
<span class="constant">binlog_cache_size</span> = 1M
<span class="constant">max_binlog_size</span>=512M
log_warnings
slow_query_log
<span class="constant">long_query_time</span> = 2
server-id = 1
<span class="constant">expire_logs_days</span> = 5
secure-file-priv=
<span class="constant">tmpdir</span>=/data/mysql_tmp
</code></pre><p>innodb_buffer_pool_size 这个选项调大可以增加innodb的内存大小,减少io操作<br>expire_logs_days 这个选项可以指定binlog保存的天数,binlog占用硬盘空间特别大,但是binlog又是恢复数据库时最宝贵的log,所以如何权衡这个问题还得结合自己项目的需要<br>secure-file-priv= 这个选项可以让其他用户写入数据,项目在合服时无法写入数据,加入这个配置可以降低数据库的安全性检查<br>tmpdir=/data/mysql_tmp 这个选项可以指定mysql在运行时使用的硬盘空间地址,默认的地址是在系统盘,而一般系统盘的空间较小,把目录指定到空间较大的目录可以有效提高数据库的io效率</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2017-05-10T07:55:00.000Z"><a href="/2017/05/10/asan/">2017-05-10</a></time>
      
      
  
    <h1 class="title"><a href="/2017/05/10/asan/">asan(Linux)</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="惊天大霹雳，超级好用的Linux程序内存检查工具，AddressSanitizer_(ASan)">惊天大霹雳，超级好用的Linux程序内存检查工具，AddressSanitizer (ASan)</h2><p>最近线上的程序总是莫名其妙崩溃,因为我们的项目使用了分布负载的机制,对于玩家的影响其实很小,但是我肯定是忍不了的…程序崩溃的core文件里面完全找不到问题所在,初步分析应该是野指针导致,仔细分析程序之后并没有发现内存释放后没有置null的情况,很可能是多线程导致的,然而代码量太大,大海捞针实在是无法找到问题所在,所以我找到了asan,项目之前一直用gcc4.4编译,完全不知道asan的存在,asan是gcc4.8以上gcc自带的内存检测库,开发自google,在gcc4.8版本以上编译链接的时候加入指定的参数即可,非常的方便好用,而且对程序的性能影响并不大,如果你的程序平时耗费的cpu和内存资源不超过50%,那么完全可以把加入asan的程序放到线上去跑.</p>
<p>首先在编译机上升级gcc,我直接升级到了最新版本gcc6.3版本(写这篇记录的时候最新版已经到gcc7.1了),升级后系统库中会新加入libasan,我们使用asan的功能都是来自于这里.<br>然后对代码进行编译和链接,编译时使用 -g -O2 -fsanitize=address -fno-omit-frame-pointer .-fsanitize=address命令就是将asan编译进来,这样编译的.o文件在运行时stack上申请的内存都会被asan接管,如果出问题asan会第一时间输出报告,如内存越界和各种非法访问. -fno-omit-frame-pointer可以防止一些优化导致指针丧失可读性.  链接时使用-fsanitize=address -fno-omit-frame-pointer选项可以让程序在heap上申请的内存被asan接管,这样asan会监控new和delete来输出内存泄漏的报告.</p>
<p>大功告成,使用asan编译和链接的程序生成好之后放到了线上环境运营,很快出现了一次宕机,asan会直接把自己的输出当做error输出,你可以查看到当前导致宕机的内存位置和变量名,文件行数,变量来源,线程信息等等非常全面的信息,得到这些信息后很快就分析出原来崩溃来自一个多线程共享的模块,而当前模块在多线程竞争资源的地方没有加锁,导致同一块内存被写坏. 问题完美解决,程序再也不会宕机了.</p>
<p>总结一下,asan在检测程序内存方面的功能实在是强大,之前也用过valgrind来检查内存泄漏,但是valgrind对性能的影响实在是太大,完全不能放到线上环境这样真实的环境下测试,而且asan给出的问题报告相当详细,基本上看一次错误报告就能解决当前导致宕机的问题,而core文件的信息由于优化和其他程序上下文的差异会导致提供的信息基本上没什么作用.宕机十次,十个core文件也无法准确定位某些野指针错误的问题.对于asan,只有一个词能表达我的心情,那就是相见恨晚…asan你值得拥有,谁用谁知道.</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-05-08T09:07:00.000Z"><a href="/2016/05/08/vsftpd/">2016-05-08</a></time>
      
      
  
    <h1 class="title"><a href="/2016/05/08/vsftpd/">Linux上vsftpd的搭建和使用</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="Linux上vsftpd的搭建和使用">Linux上vsftpd的搭建和使用</h2><p>1.查看是否安装vsftp</p>
<pre><code>rpm -<span class="keyword">qa</span> | <span class="keyword">grep</span> vsftpd
</code></pre><p>   如果出现：</p>
<pre><code><span class="tag">vsftpd-3</span><span class="class">.0</span><span class="class">.2-10</span><span class="class">.el7</span><span class="class">.x86_64</span>
</code></pre><p>   说明已经安装了vsftpd，如果没有安装<br>   使用命令安装：</p>
<pre><code>yum -y <span class="keyword">install</span> vsftpd
</code></pre><p>2,配置vsftpd</p>
<pre><code><span class="title">whereis</span> vsftpd
</code></pre><p>   出现：</p>
<pre><code><span class="string">vsftpd:</span> <span class="regexp">/usr/</span>sbin<span class="regexp">/vsftpd /</span>etc<span class="regexp">/vsftpd /</span>usr<span class="regexp">/share/</span>man<span class="regexp">/man8/</span>vsftpd<span class="number">.8</span>.gz
</code></pre><p>   到 /etc/vsftpd 目录下配置 vsftpd.conf</p>
<pre><code><span class="setting">pam_service_name=<span class="value">vsftpd             //设置服务名字，防火墙设置里要用</span></span>
<span class="setting">userlist_enable=<span class="value"><span class="keyword">YES</span>                 //访问限制打开</span></span>
<span class="setting">tcp_wrappers=<span class="value"><span class="keyword">YES</span>                    //防火墙打开</span></span>
<span class="setting">local_root=<span class="value">/haizhan                 //ftp的根目录</span></span>
<span class="setting">listen_port=<span class="value"><span class="number">19008</span>                   //修改ftp的默认端口<span class="number">21</span>到<span class="number">19008</span></span></span>
<span class="setting">listen=<span class="value"><span class="keyword">YES</span>                      </span></span>
<span class="setting">pasv_min_port=<span class="value"><span class="number">19010</span>                 //pasv模式分配给客户端可以连接的端口范围</span></span>
<span class="setting">pasv_max_port=<span class="value"><span class="number">19020</span></span></span>
<span class="setting">pasv_promiscuous=<span class="value"><span class="keyword">YES</span>                //关闭pasv的安全检查</span></span>
<span class="setting">pasv_enable=<span class="value"><span class="keyword">YES</span>                     //使用pasv模式</span></span>
<span class="setting">pasv_addr_resolve=<span class="value"><span class="keyword">YES</span>               //设置外网地址开关</span></span>
<span class="setting">pasv_address=<span class="value"><span class="number">120.120</span>.<span class="number">120.120</span>        //如果这台机器需要对外网提供ftp的pasv服务，需要在这里设置本机外网地址</span></span>
<span class="setting">listen_ipv6=<span class="value"><span class="keyword">NO</span>                      //关闭ipv6才能正常工作</span></span>
</code></pre><p>上面这些配置全部是必要配置，必须全部配置。</p>
<p>3,修改FTP系统默认端口<br>   修改 /etc/services</p>
<pre><code>ftp             <span class="number">19008</span>/tcp
ftp             <span class="number">19008</span>/udp
</code></pre><p>4,配置访问限制<br>  1.修改/etc/hosts.deny<br>  加入 :</p>
<pre><code><span class="keyword">vsftpd</span>:<span class="literal">ALL</span>
</code></pre><p>  2.修改/etc/hosts.allow<br>  加入白名单ip，如：</p>
<pre><code>vsftpd:<span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span>
vsftpd:<span class="number">120.1</span><span class="number">.1</span><span class="number">.1</span>
vsftpd:<span class="number">192.168</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span>   <span class="comment">//限定网段的，没有试过。</span>
</code></pre><p> 5,添加用户</p>
<pre><code>useradd <span class="operator">-d</span> /zhanjian <span class="operator">-s</span> /sbin/nologin haizhan
passwd haizhan
</code></pre>
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-11-12T09:18:53.000Z"><a href="/2015/11/12/explicit&extern/">2015-11-12</a></time>
      
      
  
    <h1 class="title"><a href="/2015/11/12/explicit&extern/">C++中的explicit和extern</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="explicit">explicit</h2><p>C++提供了关键字explicit，可以阻止不应该允许的经过转换构造函数进行的隐式转换的发生。声明为explicit的构造函数不能在隐式转换中使用<br>C++中， 一个参数的构造函数(或者除了第一个参数外其余参数都有默认值的多参构造函数)， 承担了两个角色。 1 是个构造器 ，2 是个默认且隐含的类型转换操作符。<br>explicit构造函数是用来防止隐式转换的。请看下面的代码：<br>    <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Test1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Test1(<span class="keyword">int</span> n)</span><br><span class="line">	&#123;</span><br><span class="line">		num=n;</span><br><span class="line">	&#125;<span class="comment">//普通构造函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> Test2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">Test2</span><span class="params">(<span class="keyword">int</span> n)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		num=n;</span><br><span class="line">	&#125;<span class="comment">//explicit(显式)构造函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	Test1 t1=<span class="number">12</span>;<span class="comment">//隐式调用其构造函数,成功</span></span><br><span class="line">	Test2 t2=<span class="number">12</span>;<span class="comment">//编译错误,不能隐式调用其构造函数</span></span><br><span class="line">	<span class="function">Test2 <span class="title">t2</span><span class="params">(<span class="number">12</span>)</span></span>;<span class="comment">//显式调用成功</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>只要是构造函数中只有一个可变参数的C++类，都要避免隐式调用。</p>
<h2 id="extern">extern</h2><h3 id="extern可置于变量或者函数前，以表示变量或者函数的定义在别的文件中，提示编译器遇到此变量或函数时，在其它模块中寻找其定义。">extern可置于变量或者函数前，以表示变量或者函数的定义在别的文件中，提示编译器遇到此变量或函数时，在其它模块中寻找其定义。</h3><p>下面这段代码没有使用任何 extern 关键字，编译中会报错。<br>    <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//A.cpp</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//B.cpp</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br></pre></td></tr></table></figure></p>
<p>添加extren关键字后可以编译通过，提示编译器i变量定义在其他模块中<br>    <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//A.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	i=<span class="number">100</span>;<span class="comment">//试图使用B中定义的全局变量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//B.cpp</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br></pre></td></tr></table></figure></p>
<h3 id="extern也可用来进行链接指定。">extern也可用来进行链接指定。</h3><p>C++支持函数重载，而过程式语言C则不支持。函数被C++编译后在符号库中的名字与C语言的不同。例如，假设某个函数的原型为：<br>void foo( int x, int y );该函数被C编译器编译后在符号库中的名字为_foo，而C++编译器则会产生像_foo_int_int之类的名字<br>（不同的编译器可能生成的名字不同，但是都采用了相同的机制，生成的新名字称为“mangled name”）。_foo_int_int这样的名字<br>包含了函数名、函数参数数量及类型信息，C++就是靠这种机制来实现函数重载的。例如，在C++中，函数void foo( int x, int y )<br>与void foo( int x, float y )编译生成的符号是不相同的，后者为_foo_int_float。同样地，C++中的变量除支持局部变量外，<br>还支持类成员变量和全局变量。用户所编写程序的类成员变量可能与全局变量同名，我们以”.”来区分。而本质上，编译器在进行编译时，<br>与函数的处理相似，也为类中的变量取了一个独一无二的名字，这个名字与用户程序中同名的全局变量名字不同。<br>在C++中引用C语言中的函数和变量，在包含C语言头文件（假设为cExample.h）时，需进行下列处理：<br>    <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="preprocessor">#<span class="keyword">include</span> <span class="string">"cExample.h"</span>	</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-05-21T09:49:39.000Z"><a href="/2015/05/21/c++11 bind的使用/">2015-05-21</a></time>
      
      
  
    <h1 class="title"><a href="/2015/05/21/c++11 bind的使用/">C++11中bind,function实战记录</a></h1>
  

    </header>
    <div class="entry">
      
        <h3 id="C++11中bind和function的使用">C++11中bind和function的使用</h3><p>最近在做的项目中有一个需求,我负责向客户端推送一组数据,这些数据需要另一个服务器程序员填充,<br>我需要调用他的一个函数,并把我的填充函数传递给他,然后在他的函数中填充这些数据.</p>
<p>首先我用普通函数试验了一下,因为c++11中的bind和function并没有使用过太多.<br>``` c++</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span>
<span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span>
<span class="keyword">struct</span> Info;
<span class="keyword">typedef</span> <span class="built_in">std</span>::function&lt;Info*()&gt; NewInfo;
<span class="keyword">typedef</span> <span class="built_in">std</span>::function&lt;<span class="keyword">void</span> (<span class="keyword">int</span> key,<span class="keyword">int</span> value)&gt; PropExecute;
<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::placeholders;

<span class="keyword">struct</span> Info
{
    <span class="keyword">int</span> key;
    <span class="keyword">int</span> value;
};

<span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(PropExecute func)</span>
</span>{
    func(<span class="number">1</span>,<span class="number">1</span>);
}
<span class="function"><span class="keyword">void</span> <span class="title">prop</span><span class="params">(<span class="keyword">int</span> key,<span class="keyword">int</span> value,NewInfo f)</span>
</span>{
    Info* info = f();
    info-&gt;key = key;
    info-&gt;value = value;
}
<span class="function">Info* <span class="title">new_info</span><span class="params">()</span>
</span>{
    <span class="keyword">return</span> <span class="keyword">new</span> Info;
}

<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>
</span>{
    test(bind(prop,_1,_2,new_info));
    <span class="keyword">return</span> <span class="number">1</span>;
}
</code></pre><p>这样写就基本实现了该功能,<code>Info</code>和<code>PropExecute</code>函数类型由我公开给服务器同事,<br>同事提供<code>test</code>函数给我调用,并在该函数内使用我传递过去的函数将数据填充(这里我用1,1填充).</p>
<p>好了,现在修改一下,把所有的普通函数都修改为类成员函数,因为项目中这些函数都是类成员函数.</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span>
<span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span>
<span class="keyword">struct</span> Info;
<span class="keyword">typedef</span> <span class="built_in">std</span>::function&lt;Info*()&gt; NewInfo;
<span class="keyword">typedef</span> <span class="built_in">std</span>::function&lt;<span class="keyword">void</span> (<span class="keyword">int</span> key,<span class="keyword">int</span> value)&gt; PropExecute;
<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::placeholders;
<span class="keyword">class</span> Attr
{
<span class="keyword">public</span>:
    Attr():key(<span class="number">1</span>),value(<span class="number">1</span>){}
    ~Attr(){};
    <span class="function"><span class="keyword">void</span> <span class="title">get_attr</span><span class="params">(PropExecute func)</span>
    </span>{
        func(key,value);
    }
    <span class="keyword">int</span> key;
    <span class="keyword">int</span> value;
};
<span class="keyword">class</span> Info
{
<span class="keyword">public</span>:
    Info():key(<span class="number">0</span>),value(<span class="number">0</span>){};
    ~Info(){};
    <span class="function">Info* <span class="title">new_info</span><span class="params">()</span>
    </span>{
        <span class="keyword">return</span> <span class="keyword">new</span> Info;
    }
    <span class="keyword">int</span> key;
    <span class="keyword">int</span> value;
};
<span class="keyword">class</span> MyClass
{
<span class="keyword">public</span>:
    MyClass(){}
    ~MyClass(){}
    <span class="function"><span class="keyword">void</span> <span class="title">set_prop</span><span class="params">(<span class="keyword">int</span> key,<span class="keyword">int</span> value,NewInfo f)</span>
    </span>{
        Info* info = f();
        info-&gt;key = key;
        info-&gt;value = value;
    }
};


<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>
</span>{
    Info info;
    Attr attr;
    MyClass myclass;
    NewInfo newinfo = <span class="built_in">std</span>::bind(&amp;Info::new_info,&amp;info);
    attr.get_attr(bind(&amp;MyClass::set_prop,&amp;myclass,_1,_2,newinfo));
    <span class="keyword">return</span> <span class="number">1</span>;
}
</code></pre><p>修改为类成员函数后就是这样了,这里遇到一个问题,<code>main</code>函数中调用<code>get_attr</code>时分成了两条代码,<br>因为写成这样编译报错<code>attr.get_attr(bind(&amp;MyClass::set_prop,&amp;myclass,_1,_2,std::bind(&amp;Info::new_info,&amp;info)));</code><br>我估计可能是类型不匹配之类的错误.总之分成两条代码就OK了. </p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-05-21T09:49:39.000Z"><a href="/2015/05/21/二义性/">2015-05-21</a></time>
      
      
  
    <h1 class="title"><a href="/2015/05/21/二义性/">关于C++继承的二义性</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="关于C++继承的二义性">关于C++继承的二义性</h2><p>天气太热写不下去代码,就翻柜子,找到c++primer翻了一下,好久不看书,记一下翻到的内容,稍微巩固下…<br>给定下面的类层次，从 VMI 类内部可以限定地访问哪些继承成员？哪些继承成员需要限定？解释你的推理。</p>
<pre><code><span class="keyword">class</span> Base {
<span class="keyword">public</span>:
    bar(<span class="keyword">int</span>);
<span class="keyword">protected</span>:
    <span class="keyword">int</span> ival;
};
<span class="keyword">class</span> Derived1 : <span class="keyword">virtual</span> <span class="keyword">public</span> Base {
<span class="keyword">public</span>:
    bar(<span class="keyword">char</span>);
    foo(<span class="keyword">char</span>);
<span class="keyword">protected</span>:
    <span class="keyword">char</span> cval;
};
<span class="keyword">class</span> Derived2 : <span class="keyword">virtual</span> <span class="keyword">public</span> Base {
<span class="keyword">public</span>:
    foo(<span class="keyword">int</span>);
<span class="keyword">protected</span>:
    <span class="keyword">int</span> ival;
    <span class="keyword">char</span> cval;
};
<span class="keyword">class</span> VMI : <span class="keyword">public</span> Derived1, <span class="keyword">public</span> Derived2 { };
</code></pre><p>从这个继承层次看，VMI类内部访问哪些没有二义性，哪些成员有二义性呢？<br>从VMI类内部可以不加限定地访问继承成员bar和ival：bar在共享基类Base和派生类Derived1中都存在，但特定派生类实例的优先级高于共享基类实例，所以在VMI类内部不加限定地访问bar，则访问到的是Derived1中的bar实例。ival在共享基类Base和派生类Derived2中都存在，同理，在VMI类中不加限定地访问ival，访问到的是Derived2中的ival实例。<br>继承成员foo和cval需要限定：二者在Derived1和Derived2中都存在，Derived1和Derived2均为Base的派生类，访问优先级相同，所以，如果在VMI类内不加限定地访问foo和cval，则会出现二义性。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-04-09T09:15:53.000Z"><a href="/2015/04/09/orm-odb/">2015-04-09</a></time>
      
      
  
    <h1 class="title"><a href="/2015/04/09/orm-odb/">orm-odb(c++)</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="基于ORM机制的C++数据库操作开源库ODB">基于ORM机制的C++数据库操作开源库ODB</h2><p>  最近在项目里遇到一个问题,关于数据库读取大量数据的,这部分代码项目里的思路是,对数据表做索引,然后依据索引排序,取出最上面的max_size(5000)条数据,然后基于后面的数据继续排序,取出最上面max_size(5000)条,依此循环直到取出最后一条数据.  开始我觉得这样可能效率会比较低,因为每次操作都要进行一次排序,我觉得用limit 0,max_size .limit 0+max_size,max_size+max_size这样的方法要快一些,后来想了一下问题的关键应该是在每次取第一条数据的时候,比如先排序再去取的话,因为建立了索引,所以排序是很快的,而且第一条马上就找到了,但是用limit 0,max_size这样的方法的话,每次查找第一条数据都要顺序数到位置,所以先排序再取数据的方法是稍微好一点的. </p>
<hr>
<p>  不过正是因为这个问题,偶然发现了一个c++的数据库操作库,基于ORM机制,google了一下ORM,全称是对象关系映射（Object Relational Mapping),简单来说就是使用这个库可以让程序员避免直接操作sql语句,数据的存储和对象直接相关,多说无益,记下使用方法以便日后用得到.</p>
<hr>
<p> 我是在windows平台上编译和测试的.这里记下windows下的使用方法:<br> 首先从<a href="http://www.codesynthesis.com/products/odb/" target="_blank" rel="external">http://www.codesynthesis.com/products/odb/</a> 下载到源码,主要是the Common Runtime Library和the Database Runtime Library,前者是ODB的基本库,后者是基于不同数据库的扩展库,后者要基于前者.我用的是mysql,所以要下载mysql的扩展库.前者没有任何依赖可以直接编译,后者要基于前者和mysql的库,我编译的时候总是不成功,后来发现我机器上安装的mysql是64位的,编译ODB的时候把win32改成X64后编译通过,以后要注意下这个问题.使用编译好的库启动官方的例子程序”hello”,一切正常.<br> 简单的用法如下:</p>
<p> 这是一个简单的person类.<br> // person.hxx</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span>

<span class="keyword">class</span> person
{
<span class="keyword">public</span>:
  person (<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; first,
          <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; last,
          <span class="keyword">unsigned</span> <span class="keyword">short</span> age);

  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span>&amp; <span class="title">first</span> <span class="params">()</span> <span class="keyword">const</span></span>;
  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span>&amp; <span class="title">last</span> <span class="params">()</span> <span class="keyword">const</span></span>;

  <span class="function"><span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="title">age</span> <span class="params">()</span> <span class="keyword">const</span></span>;
  <span class="function"><span class="keyword">void</span> <span class="title">age</span> <span class="params">(<span class="keyword">unsigned</span> <span class="keyword">short</span>)</span></span>;

<span class="keyword">private</span>:
  <span class="built_in">std</span>::<span class="built_in">string</span> first_;
  <span class="built_in">std</span>::<span class="built_in">string</span> last_;
  <span class="keyword">unsigned</span> <span class="keyword">short</span> age_;
};
</code></pre><p> 使用ODB后修改如下:</p>
<p> // person.hxx</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span>

<span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;odb/core.hxx&gt;</span>     // (1)</span>

<span class="preprocessor">#<span class="keyword">pragma</span> db object           <span class="comment">// (2)</span></span>
<span class="keyword">class</span> person
{
  ...

<span class="keyword">private</span>:
  person () {}              <span class="comment">// (3)</span>

  <span class="keyword">friend</span> <span class="keyword">class</span> odb::access; <span class="comment">// (4)</span>

  <span class="preprocessor">#<span class="keyword">pragma</span> db id auto        <span class="comment">// (5)</span></span>
  <span class="keyword">unsigned</span> <span class="keyword">long</span> id_;        <span class="comment">// (5)</span>

  <span class="built_in">std</span>::<span class="built_in">string</span> first_;
  <span class="built_in">std</span>::<span class="built_in">string</span> last_;
  <span class="keyword">unsigned</span> <span class="keyword">short</span> age_;
};
</code></pre><p> 使用这个sql文件建立数据表<br> //This file was generated by ODB, object-relational mapping (ORM) compiler for C++.</p>
<pre><code><span class="operator"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`person`</span>;</span>

<span class="operator"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`person`</span> (
  <span class="string">`id`</span> <span class="built_in">BIGINT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> PRIMARY <span class="keyword">KEY</span> AUTO_INCREMENT,
  <span class="string">`first`</span> <span class="built_in">TEXT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,
  <span class="string">`last`</span> <span class="built_in">TEXT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,
  <span class="string">`age`</span> <span class="built_in">SMALLINT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>)
 <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span>
</code></pre><p>测试例子如下,执行commit函数后三个person类对象的数据就写入了数据库中,真的非常方便简洁.<br> //driver.cxx</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span>   // std::auto_ptr</span>
<span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span>

<span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;odb/database.hxx&gt;</span></span>
<span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;odb/transaction.hxx&gt;</span></span>

<span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;odb/mysql/database.hxx&gt;</span></span>

<span class="preprocessor">#<span class="keyword">include</span> <span class="string">"person.hxx"</span></span>
<span class="preprocessor">#<span class="keyword">include</span> <span class="string">"person-odb.hxx"</span></span>

using namespace std<span class="comment">;</span>
using namespace odb::core<span class="comment">;</span>

<span class="built_in">int</span>
main (<span class="built_in">int</span> argc, char* argv[])
{
  try
  {
    //auto_ptr&lt;database&gt; db (new odb::mysql::database (argc, argv))<span class="comment">;</span>
    auto_ptr&lt;database&gt; db (new odb::mysql::database(<span class="string">"dll"</span>,<span class="string">"dll"</span>,<span class="string">"odb_test"</span>,<span class="string">"localhost"</span>,<span class="number">3306</span>))<span class="comment">;</span>
    unsigned long john_id, jane_id, joe_id<span class="comment">;</span>

    // Create a few persistent person objects.
    //
    {
      person john (<span class="string">"John"</span>, <span class="string">"Doe"</span>, <span class="number">33</span>)<span class="comment">;</span>
      person jane (<span class="string">"Jane"</span>, <span class="string">"Doe"</span>, <span class="number">32</span>)<span class="comment">;</span>
      person joe (<span class="string">"Joe"</span>, <span class="string">"Dirt"</span>, <span class="number">30</span>)<span class="comment">;</span>

      transaction t (db-&gt;begin ())<span class="comment">;</span>

      // Make objects persistent <span class="literal">and</span> save their ids <span class="keyword">for</span> later use.
      //
      john_id = db-&gt;persist (john)<span class="comment">;</span>
      jane_id = db-&gt;persist (jane)<span class="comment">;</span>
      joe_id = db-&gt;persist (joe)<span class="comment">;</span>

      t.commit ()<span class="comment">;</span>
    }
  }
  catch (<span class="keyword">const</span> odb::exception&amp; e)
  {
    cerr &lt;&lt; e.what () &lt;&lt; endl<span class="comment">;</span>
    <span class="keyword">return</span> <span class="number">1</span><span class="comment">;</span>
  }
}
</code></pre><p>这是ODB官方自带的例子,我们在使用ODB的时候需要自己生成person类的C++文件,使用官方的ODB Compiler,下载后将ODB的bin目录添加到系统的环境变量中,通过person.hxx文件即可得到ODB需要的其他c++文件,类似protobuf的使用.<br>    odb -d mysql –generate-query –generate-schema person.hxx<br>这条命令即可生成person-odb.hxx, person-odb.ixx, person-odb.cxx这三个文件,这样配合编译好的库文件就可以操作数据库了.</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-02-12T07:12:53.000Z"><a href="/2015/02/12/libcurl/">2015-02-12</a></time>
      
      
  
    <h1 class="title"><a href="/2015/02/12/libcurl/">libcurl</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="Windows下libcurl静态库的编译和使用">Windows下libcurl静态库的编译和使用</h2><p>  最近在玩一个游戏,这游戏的服务器是http通信的,就想伪造一些数据看看.想起了curl,于是去下载,结果编译半天总是出错,又浪费了好多时间,现在成功了,记下来.</p>
<hr>
<p> 首先从这里下载最新的源代码<br>  <a href="http://curl.haxx.se/download.html" target="_blank" rel="external">http://curl.haxx.se/download.html</a><br> libcurl是源码,curl是一个http的工具,反正我用libcurl的源码就够了.</p>
<p> 打开找到相应的VC版本工程用VS打开,我用的是VS2012,相应的版本是VC11.</p>
<p> 一开始编译出错,因为这个版本里包含了ssh和ssl的第三方库,我也用不着所以在预编译宏里把关于ssl和ssh的都去掉.</p>
<p> 然后继续编译lib静态库成功了,新建测试工程加入头文件和生成的附加库libcurld.lib,发现有无法识别的外部符号错误,网上找了半天解决方法.</p>
<p> 最后的解决方法是. libcurl的预编译设定为<br><code>WIN32</code><br><code>_DEBUG</code><br><code>BUILDING_LIBCURL</code><br> 测试项目的预编译设置为<br><code>BUILDING_LIBCURL</code><br> 并且在测试项目头文件中添加以下内容<br><code>#define CURL_STATICLIB</code><br><code>#if defined(_DEBUG)</code><br><code>#pragma comment(lib, &quot;libcurld.lib&quot;)</code><br><code>#else</code><br><code>#pragma comment(lib, &quot;libcurl.lib&quot;)</code><br><code>#endif</code><br><code>#pragma comment(lib,&quot;winmm.lib&quot; )</code><br><code>#pragma comment(lib,&quot;ws2_32.lib&quot; )</code><br><code>#pragma comment(lib,&quot;wldap32.lib&quot; )</code></p>
<p>再次编译,搞定.</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





<nav id="pagination">
  
  
    <a href="/page/2/" class="alignright next">下一页</a>
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:yoursite.com">
  </form>
</div>

  

  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/C/">C++</a><small>10</small></li>
  
    <li><a href="/tags/DB/">DB</a><small>2</small></li>
  
    <li><a href="/tags/FTP/">FTP</a><small>1</small></li>
  
    <li><a href="/tags/HTTP/">HTTP</a><small>1</small></li>
  
    <li><a href="/tags/Linux/">Linux</a><small>5</small></li>
  
    <li><a href="/tags/Redis/">Redis</a><small>1</small></li>
  
    <li><a href="/tags/博客/">博客</a><small>12</small></li>
  
    <li><a href="/tags/技术/">技术</a><small>13</small></li>
  
    <li><a href="/tags/文章/">文章</a><small>10</small></li>
  
    <li><a href="/tags/源代码/">源代码</a><small>1</small></li>
  
    <li><a href="/tags/转载/">转载</a><small>1</small></li>
  
  </ul>
</div>


  
<div class="widget tagcloud">
  <h3 class="title">标签云</h3>
  <div class="entry">
    <a href="/tags/C/" style="font-size: 16px;">C++</a> <a href="/tags/DB/" style="font-size: 12px;">DB</a> <a href="/tags/FTP/" style="font-size: 10px;">FTP</a> <a href="/tags/HTTP/" style="font-size: 10px;">HTTP</a> <a href="/tags/Linux/" style="font-size: 14px;">Linux</a> <a href="/tags/Redis/" style="font-size: 10px;">Redis</a> <a href="/tags/博客/" style="font-size: 18px;">博客</a> <a href="/tags/技术/" style="font-size: 20px;">技术</a> <a href="/tags/文章/" style="font-size: 16px;">文章</a> <a href="/tags/源代码/" style="font-size: 10px;">源代码</a> <a href="/tags/转载/" style="font-size: 10px;">转载</a>
  </div>
</div>


  <div class="widget tag">
<h3 class="title">友情链接</h3>
<ul class="entry">
<li><a href="http://zipperary.com/" title="Zippera's Blog">Zippera</a></li>
</ul>
</div>

  <iframe width="100%" height="550" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=550&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=1&isFans=1&uid=1235899094&verifier=a6902c2e&dpc=1"></iframe>
</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2018 shafeng
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>